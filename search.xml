<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android studio 统一替换JCenter为国内阿里云maven]]></title>
    <url>%2F2017%2F03%2F06%2Freplace-jcenter-to-aliyun-maven%2F</url>
    <content type="text"><![CDATA[有的时候同步一个依赖要等好久，浪费好多宝贵时间，编译速度也变的很慢，那么今天我们就彻底解决这个问题。使用阿里云maven替代jCenter，加快编译速度。 在你的USER_HOME/.gradle/目录下，新建一个文件init.gradle，把这一段内容拷贝进去。 1234567891011121314151617allprojects&#123; repositories &#123; def REPOSITORY_URL = &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; all &#123; ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository)&#123; def url = repo.url.toString() if (url.startsWith(&apos;https://repo1.maven.org/maven2&apos;) || url.startsWith(&apos;https://jcenter.bintray.com/&apos;)) &#123; project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $REPOSITORY_URL.&quot; remove repo &#125; &#125; &#125; maven &#123; url REPOSITORY_URL &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法查找与快速排序]]></title>
    <url>%2F2016%2F12%2F23%2Fquicksort-and-binarysearch%2F</url>
    <content type="text"><![CDATA[二分法查找当数据量很大适宜采用该方法。采用二分法查找时，数据需是有序不重复的。 基本思想：假设数据是按升序排序的，对于给定值 x，从序列的中间位置开始比较，如果当前位置值等于 x，则查找成功；若 x 小于当前位置值，则在数列的前半段中查找；若 x 大于当前位置值则在数列的后半段中继续查找，直到找到为止。 假设有一个数组 { 12, 23, 34, 45, 56, 67, 77, 89, 90 }，现要求采用二分法找出指定的数值并将其在数组的索引返回，如果没有找到则返回 -1。代码如下： 1234567891011121314151617181920212223242526public class Search &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123; 12, 23, 34, 45, 56, 67, 77, 89, 90 &#125;; System.out.println(binarySearch(arr, 12)); System.out.println(binarySearch(arr, 45)); System.out.println(binarySearch(arr, 67)); System.out.println(binarySearch(arr, 89)); System.out.println(binarySearch(arr, 99)); &#125; public static int binarySearch(int[] arr, int key) &#123; int start = 0; int end = arr.length - 1; while (start &lt;= end) &#123; int middle = (start + end) / 2; if (key &lt; arr[middle]) &#123; end = middle - 1; &#125; else if (key &gt; arr[middle]) &#123; start = middle + 1; &#125; else &#123; return middle; &#125; &#125; return -1; &#125;&#125; 二分法查找的时间复杂度为O(logN)。 快速排序算法思想：基于分治的思想，是冒泡排序的改进型。首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换lo和hi位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环，直到lo&gt;=hi,然后把基准点的值放到hi这个位置。一次排序就完成了。以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。 12345678910111213141516171819202122232425public static int partition(int []array,int lo,int hi)&#123; //固定的切分方式 int key=array[lo]; while(lo&lt;hi)&#123; while(array[hi]&gt;=key&amp;&amp;hi&gt;lo)&#123;//从后半部分向前扫描 hi--; &#125; array[lo]=array[hi]; while(array[lo]&lt;=key&amp;&amp;hi&gt;lo)&#123;从前半部分向后扫描 lo++; &#125; array[hi]=array[lo]; &#125; array[hi]=key; return hi; &#125; public static void sort(int[] array,int lo ,int hi)&#123; if(lo&gt;=hi)&#123; return ; &#125; int index=partition(array,lo,hi); sort(array,lo,index-1); sort(array,index+1,hi); &#125; 快速排序的时间复杂度为O(NlogN)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Amigo 源码解读]]></title>
    <url>%2F2016%2F11%2F15%2Fanalysis-amigo-source%2F</url>
    <content type="text"><![CDATA[现在 hotfix 框架有很多，原理大同小异，基本上是基于qq空间这篇文章 或者微信的方案。可惜的是微信的 Tinker 以及 QZone 都没有将其具体实现开源出来，只是在文章中分析了现有各个 hotfix 框架的优缺点以及他们的实现方案。Amigo 原理与 Tinker 基本相同，但是在 Tinker 的基础上，进一步实现了 so 文件、资源文件、Activity、BroadcastReceiver 的修复，几乎可以号称全面修复，不愧Amigo（朋友）这个称号，能在危急时刻送来全面的帮助。 在Amigo这个类中实现了主要的修复工作。我们一起追追看，到底是怎样的实现。 Amigo.java 1234567...if (demoAPk.exists() &amp;&amp; isSignatureRight(this, demoAPk)) &#123; SharedPreferences sp = getSharedPreferences(SP_NAME, MODE_MULTI_PROCESS); String demoApkChecksum = checksum(demoAPk); boolean isFirstRun = !sp.getString(NEW_APK_SIG, "").equals(demoApkChecksum);... 这段代码中，首先检查是否有补丁包，并且签名正确，如果正确，则通过检验校验和是否与之前的检验和相同，不同则为检测到新的补丁包。 释放Apk当这是新的补丁包时，首先第一件事就是释放。ApkReleaser.work(this, layoutId, themeId)在这个方法中最终会去开启一个 ApkReleaseActivity，而这个 Activity 的layout 和 theme 就是之前从配置中解析出来，在 work 方法中传进来的layoutId 和 themeId。 ApkReleaseActivity.java 123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... new Thread() &#123; @Override public void run() &#123; super.run(); DexReleaser.releaseDexes(demoAPk.getAbsolutePath(), dexDir.getAbsolutePath()); NativeLibraryHelperCompat.copyNativeBinaries(demoAPk, nativeLibraryDir); dexOptimization(); handler.sendEmptyMessage(WHAT_DEX_OPT_DONE); &#125; &#125;.start();&#125; 在 ApkReleaseActivity 的 onCreate() 方法中会开启一个线程去进行一系列的释放操作，这些操作十分耗时，目前在不同的机子上测试，从几秒到二十几秒之间不等，如果就这样黑屏在用户前面未免太不优雅，所以 Amigo 开启了一个新的进程，启动这个 Activity。在这个线程中，做了三件微小的事情： 释放 Dex 到指定目录 拷贝 so 文件到 Amigo 的指定目录下拷贝 so 文件是通过反射去调用 NativeLibraryHelper这个类的nativeCopyNativeBinaries()方法，但这个方法在不同版本上有不同的实现。 * 如果版本号在21以下 **NativeLibraryHelper** 123456public static int copyNativeBinariesIfNeededLI(File apkFile, File sharedLibraryDir) &#123; final String cpuAbi = Build.CPU_ABI; final String cpuAbi2 = Build.CPU_ABI2; return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi, cpuAbi2); &#125; 会去反射调用这个方法，其中系统会自动判断出 primaryAbi 和 secondAbi。 如果版本号在21以上copyNativeBinariesIfNeededLI(file, file)这个方法已经被废弃了，需要去反射调用这个方法 NativeLibraryHelper 12345678910public static int copyNativeBinaries(Handle handle, File sharedLibraryDir, String abi) &#123; for (long apkHandle : handle.apkHandles) &#123; int res = nativeCopyNativeBinaries(apkHandle, sharedLibraryDir.getPath(), abi, handle.extractNativeLibs, HAS_NATIVE_BRIDGE); if (res != INSTALL_SUCCEEDED) &#123; return res; &#125; &#125; return INSTALL_SUCCEEDED; &#125; 所以首先得去获得一个NativeLibraryHelper$Handle类的实例。之后就是找 primaryAbi。Amigo 先对机器的位数做了判断，如果是64位的机子，就只找64位的 abi，如果是32位的，就只找32位的 abi。然后将 Handle 实例当做参数去调用NativeLibraryHelper的findSupportedAbi来获得primaryAbi。最后再去调用copyNativeBinaries去拷贝 so 文件。 对于 so 文件加载的原理可以参考这篇文章 优化 dex 文件 ApkReleaseActivity.java 1234567private void dexOptimization() &#123; ... for (File dex : validDexes) &#123; new DexClassLoader(dex.getAbsolutePath(), optimizedDir.getAbsolutePath(), null, DexUtils.getPathClassLoader()); Log.e(TAG, "dexOptimization finished--&gt;" + dex); &#125; &#125; DexClassLoader 没有做什么事情，只是调用了父类构造器，他的父类是 BaseDexClassLoader。在 BaseDexClassLoader 的构造器中又去构造了一个DexPathList 对象。 在DexPathList类中，有一个 Element 数组 DexPathList 12/** list of dex/resource (class path) elements */private final Element[] dexElements; Element 就是对 Dex 的封装。所以一个 Element 对应一个 Dex。这个 Element 在后文中会提到。 优化 dex 只需要在构造 DexClassLoader 对象的时候将 dex 的路径传进去，系统会在最后会通过DexFile的 DexFile.java 12native private static int openDexFile(String sourceName, String outputName, int flags) throws IOException; 来这个方法来加载 dex，加载的同时会对其做优化处理。 这三项操作完成之后，通知优化完毕，之后就关闭这个进程，将补丁包的校验和保存下来。这样第一步释放 Apk 就完成了。之后就是重头戏替换修复。 替换修复###替换classLoader Amigo 先行构造一个AmigoClassLoader对象，这个AmigoClassLoader是一个继承于PathClassLoader的类，把补丁包的 Apk 路径作为参数来构造AmigoClassLoader对象，之后通过反射替换掉 LoadedApk 的 ClassLoader。这一步是 Amigo 的关键所在。 ###替换Dex 之前提到，每个 dex 文件对应于一个PathClassLoader，其中有一个 Element[]，Element 是对于 dex 的封装。 Amigo.java 1234567891011121314151617181920private void setDexElements(ClassLoader classLoader) throws NoSuchFieldException, IllegalAccessException &#123; Object dexPathList = getPathList(classLoader); File[] listFiles = dexDir.listFiles(); List&lt;File&gt; validDexes = new ArrayList&lt;&gt;(); for (File listFile : listFiles) &#123; if (listFile.getName().endsWith(".dex")) &#123; validDexes.add(listFile); &#125; &#125; File[] dexes = validDexes.toArray(new File[validDexes.size()]); Object originDexElements = readField(dexPathList, "dexElements"); Class&lt;?&gt; localClass = originDexElements.getClass().getComponentType(); int length = dexes.length; Object dexElements = Array.newInstance(localClass, length); for (int k = 0; k &lt; length; k++) &#123; Array.set(dexElements, k, getElementWithDex(dexes[k], optimizedDir)); &#125; writeField(dexPathList, "dexElements", dexElements);&#125; 在替换dex时，Amigo 将补丁包中每个 dex 对应的 Element 对象拿出来，之后组成新的 Element[]，通过反射，将现有的 Element[] 数组替换掉。在 QZone 的实现方案中，他们是通过将新的 dex 插到 Element[] 数组的第一个位置，这样就会先加载新的 dex ，微信的方案是下发一个 DiffDex，然后在运行时与旧的 dex 合成一个新的 dex。但是 Amigo 是下发一个完整的 dex直接替换掉了原来的 dex。与其他的方案相比，Amigo 因为直接替换原来的 dex ,兼容性更好，能够支持修复的方面也更多。但是这也导致了 Amigo 的补丁包会较大，当然，也可以发一个利用 BsDiff 生成的差分包，在本地合成新的 apk 之后再放到 Amigo 的指定目录下。 ###替换动态链接库 Amigo.java 1234567891011private void setNativeLibraryDirectories(AmigoClassLoader hackClassLoader) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; injectSoAtFirst(hackClassLoader, nativeLibraryDir.getAbsolutePath()); nativeLibraryDir.setReadOnly(); File[] libs = nativeLibraryDir.listFiles(); if (libs != null &amp;&amp; libs.length &gt; 0) &#123; for (File lib : libs) &#123; lib.setReadOnly(); &#125; &#125;&#125; so 文件的替换跟 QZone 替换 dex 原理相差不多，也是利用 ClassLoader 加载 library 的时候，将新的 library 加到数组前面，保证先加载的是新的 library。但是这里会有几个小坑。 DexUtils.java 12345678910111213141516171819202122232425262728293031public static void injectSoAtFirst(ClassLoader hackClassLoader, String soPath) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123; Object[] baseDexElements = getNativeLibraryDirectories(hackClassLoader); Object newElement; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Constructor constructor = baseDexElements[0].getClass().getConstructors()[0]; constructor.setAccessible(true); Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes(); Object[] args = new Object[parameterTypes.length]; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; if (parameterTypes[i] == File.class) &#123; args[i] = new File(soPath); &#125; else if (parameterTypes[i] == boolean.class) &#123; args[i] = true; &#125; &#125; newElement = constructor.newInstance(args); &#125; else &#123; newElement = new File(soPath); &#125; Object newDexElements = Array.newInstance(baseDexElements[0].getClass(), 1); Array.set(newDexElements, 0, newElement); Object allDexElements = combineArray(newDexElements, baseDexElements); Object pathList = getPathList(hackClassLoader); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; writeField(pathList, "nativeLibraryPathElements", allDexElements); &#125; else &#123; writeField(pathList, "nativeLibraryDirectories", allDexElements); &#125; &#125; 注入 so 文件到数组时，会发现在不同的版本上封装 so 文件的是不同的类，在版本23以下，是File DexPathList.java 12/** list of native library directory elements */private final File[] nativeLibraryDirectories; 在23以上却是改成了Element DexPathList.java 12/** List of native library path elements. */private final Element[] nativeLibraryPathElements; 因此在23以上，Amigo 通过反射去构造一个 Element 对象。之后就是将 so 文件插到数组的第一个位置就行了。第二个小坑是nativeLibraryDir要设置成readOnly。 DexPathList.java 123456789101112131415public String findNativeLibrary(String name) &#123; maybeInit(); if (isDirectory) &#123; String path = new File(dir, name).getPath(); if (IoUtils.canOpenReadOnly(path)) &#123; return path; &#125; &#125; else if (zipFile != null) &#123; String entryName = new File(dir, name).getPath(); if (isZipEntryExistsAndStored(zipFile, entryName)) &#123; return zip.getPath() + zipSeparator + entryName; &#125; &#125; return null;&#125; 在ClassLoader 去寻找本地库的时候，如果 so 文件没有设置成ReadOnly的话是会不会返回路径的，这样就会报错了。 ###替换资源文件 Amigo.java 1234567...AssetManager assetManager = AssetManager.class.newInstance();Method addAssetPath = getDeclaredMethod(AssetManager.class, "addAssetPath", String.class);addAssetPath.setAccessible(true);addAssetPath.invoke(assetManager, demoAPk.getAbsolutePath());setAPKResources(assetManager)... 想要更新资源文件，只需要更新Resource中的 AssetManager 字段。AssetManager提供了一个方法addAssetPath。将新的资源文件路径加到AssetManager中就可以了。在不同的 configuration 下，会对应不同的 Resource 对象，所以通过 ResourceManager 拿到所有的 configuration 对应的 resource 然后替换其 assetManager。 ###替换原有 Application Amigo.java 12345678910...Class acd = classLoader.loadClass("me.ele.amigo.acd");String applicationName = (String) readStaticField(acd, "n");Application application = (Application) classLoader.loadClass(applicationName).newInstance();Method attach = getDeclaredMethod(Application.class, "attach", Context.class);attach.setAccessible(true);attach.invoke(application, getBaseContext());setAPKApplication(application);application.onCreate();... 在编译过程中，Amigo 的插件将 app 的 application 替换成了 Amigo，并且将原来的 application 的 name 保存在了一个名为acd的类中，该修复的都修复完了是时候将原来的 application 替换回来了。拿到原有 Application 名字之后先调用 application 的attach(context)，然后将 application 设回到 loadedApk 中，最后调用oncreate()，执行原有 Application 中的逻辑。这之后，一个修复完的 app 就出现在用户面前。优秀的库~ Amigo 插件前文提到 Amigo 在编译期利用插件替换了 app 原有的 application，那这一个操作是怎么实现的呢？ AmigoPlugin.groovy 12345File manifestFile = output.processManifest.manifestOutputFile def manifest = new XmlParser().parse(manifestFile) def androidTag = new Namespace("http://schemas.android.com/apk/res/android", 'android') applicationName = manifest.application[0].attribute(androidTag.name) manifestFile.text = manifestFile.text.replace(applicationName, "me.ele.amigo.Amigo") 首先，Amigo Plugin 将 AndroidManifest.xml 文件中的applicationName 替换成 Amigo。 AmigoPlugin.groovy 1234567891011Node node = (new XmlParser()).parse(manifestFile)Node appNode = nullfor (Node n : node.children()) &#123; if (n.name().equals("application")) &#123; appNode = n; break &#125;&#125;Node hackAppNode = new Node(appNode, "activity")hackAppNode.attributes().put("android:name", applicationName)manifestFile.text = XmlUtil.serialize(node) 之后，Amigo Plugin 做了很 hack 的一步，就是在 AndroidManifest.xml 中将原来的 application 做为一个 Activity 。我们知道 MultiDex 分包的规则中，一定会将 Activity 放到主 dex 中，Amigo Plugin 为了保证原来的 application 被替换后仍然在主 dex 中，就做了这个十分 hack 的一步。机智的少年。 接下来会再去判断是否开启了混淆，如果有混淆的话，查找 mapping 文件，将 applicationName 字段换成混淆后的名字。 下一步会去执行 GenerateCodeTask，在这个 task 中会生成一个 Java 文件，这个文件就是上文提到过得acd.java，并且将模板中的 appName 替换成applicationName。然后执行 javaCompile task，编译 Java 代码。最后还要做一件事，就是修改 maindexlist.txt。被定义在这个文件中的类会被加到主 dex 中，所以 Amigo plugin 在collectMultiDexInfo方法中扫描加到主 dex 的类，然后再在扫描的结果中加上 acd.class，把这些内容全部加到 maindexlist.txt。到此Amigo plugin 的任务就完成了。Amigo plugin 的主要目的是在编译期用 amigo 替换掉原来的 application，但是还得保存下来这个 application，因为之后还得在运行时将这个 application 替换回来。 总结Amigo 几乎实现了全方位的修复，通过替换 ClassLoader，直接全量替换 dex 的思路，保证了兼容性，成功率，但是可能下发的补丁包会比较大。还有一点 Amigo 的精彩之处就是利用 Amigo 替换了 app 原有的 application，这一点保证了 Amigo 连 application 都能修复。以后可能唯一不能修复的就是 Amigo 自身了。 最后我们比较下目前几个 hotfix 方案： 对比项 Amigo Tinker nuwa/QZone AndFix Dexposed 类替换 yes yes yes no no lib替换 yes yes no no no 资源替换 yes yes yes no no 全平台支持 yes yes yes yes no 即时生效 optional no no yes yes 性能损耗 无 较小 较大 较小 较小 补丁包大小 较大 较小 较大 一般 一般 开发透明 yes yes yes no no 复杂度 无 较低 较低 复杂 复杂 gradle支持 yes yes yes no no 接口文档 丰富 丰富 一般 一般 较少 占Rom体积 较大 较大 较小 较小 较小 成功率 100% 较好 很高 一般 一般 from https://github.com/eleme/Amigo/blob/master/blog.md]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>增量更新热修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Looper、Handler、MessageQueue原理及源码解析]]></title>
    <url>%2F2016%2F10%2F15%2Fanalysis-looper-handler-message-thread%2F</url>
    <content type="text"><![CDATA[Handler在开发中还是很常用的，通常我们主要用来在子线程中更新UI，其实深入点的话就是涉要另外及Looper、MessageQueue。当然我们也可以让他工作在非UI主线程，怎么用呐？看下边小栗子。 下边我们写个简单的小例子来引入要讲的源码分析。 1234567891011121314private class LooperThread extends Thread &#123; @Override public void run() &#123; Looper.prepare(); mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; //TODO do somethings return false; &#125; &#125;); Looper.loop(); &#125;&#125; 那么上边的例子Handler工作在哪歌线程中呐？？答案是在LooperThread线程，而非主线程。看看以下Handler构造器源码就能明白。 Looper.java1234567891011121314151617181920212223public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//①获取当前的Looper if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue;//②获取当前的MassageQueue mCallback = callback;//③当前的Callback mAsynchronous = async;&#125; 那么为什么在UI主线程中使用Handler没有Looper.prepare和Looper.loop()呐？？答案就是，在创建Activity时候，系统已经为我们调用了Looper.prepareMainLooper()，所以这个时候在我们UI主线程中直接new Handler()时，Handler就工作在主线程，所以我们就可以用来更新UI界面。 ActivityThread.java12345678910111213141516171819202122public static void main(String[] args) &#123; ...... Looper.prepareMainLooper();// ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); ......&#125; Looper.java123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125; Looper、Handler准备好了，接下来我们要sendMessage()了，最终会调用到queue.enqueueMessage(msg, uptimeMillis)，将Message入队。。。 Handler.java123456789101112131415161718public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 最终Looper.loop()会从MessageQueue中轮询Message,然后dispatchMessage()回调到Handler的Callback中dispatchMessage()方法。。。 Looper.java1234567891011121314151617181920public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; ...... for (;;) &#123; Message msg = queue.next(); // might block ...... try &#123; msg.target.dispatchMessage(msg);//target即是上边sendMessage()时的handler &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ...... &#125; &#125; 这样完成了一一个线程的整个的Looper、Handler、MessageQueue流程。。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavascriptInterface与WebChromeClient.onJsPrompt()实现的Android Webview与js交互]]></title>
    <url>%2F2016%2F08%2F07%2Fprinciple-of-interactive-between-webview-and-javascript%2F</url>
    <content type="text"><![CDATA[在Android开发中，能实现Js调用Nactive，有4种方法： 1234JavascriptInterfaceWebViewClient.shouldOverrideUrlLoading()WebChromeClient.onConsoleMessage()WebChromeClient.onJsPrompt() 这里我们讨论下第一种@JavascriptInterface注解实现，和第四种就是WebChromeClient.onJsPrompt() js注入的实现。下面来详细讲解一下二者的使用方式，原理，其他请阅读扩展JsBridge实现JavaScript和Java的互相调用-QQ音乐技术团队。 @JavascriptInterface实现实现步骤： 设置WebView支持js脚本 为提供给js调用的方法加上@JavascriptInterface注解 给WebView添加js接口 1234567class JsObject &#123; @JavascriptInterface public String toString() &#123; return &quot;injectedObject&quot;; &#125; &#125; webView.addJavascriptInterface(new JsObject(), &quot;injectedObject&quot;); webView.loadData(&quot;&quot;, &quot;text/html&quot;, null); webView.loadUrl(&quot;javascript:alert(injectedObject.toString())&quot;); 这种方式不安全，因为这个接口允许JavaScript控制宿主应用程序，在4.2的版本前存在重大安全隐患，JavaScript 可以使用反射访问注入webview的java对象的public fields，在一个包含不信任内容的WebView中使用这个方法，会允许攻击者去篡改宿主应用程序，使用宿主应用程序的权限执行java代码。因此4.2以后，任何为JS暴露的接口，都需要加JavascriptInterface。 这种方式当有js回调函数需要android端执行时，都需要将匿名回调函数赋值给全局函数才能供android端回调，增加了js和android端通信的封装层的低效代码量。 Javascript注入实现先来说说原理吧，当js调用prompt()方法时，WebChromeClient.onJsPrompt()方法会被触发，当js触发Android提供的接口方法时，将该方法的方法名称、参数类型、参数值转成json，然后通过prompt方法传递给android端，android端解析json并通过反射执行对应的方法，同时也支持执行匿名回调。整个流程比较复杂，看图： 为WebView绑定WebChormeClient监听，在Html加载进度25%时进行js注入(注入的js是根据android提供给js的对象类名动态生成);动态注入的js代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758javascript: (function(b) &#123; console.log(&quot;HostApp initialization begin&quot;); var a = &#123; queue: [], callback: function() &#123; var d = Array.prototype.slice.call(arguments, 0);//获取该函数参数并转换为Array数组 var c = d.shift();//取得数组第一个元素 var e = d.shift(); this.queue[c].apply(this, d);//新建一个对象 属性名称为取得的c，并将d数组作为他的值。然后将这个对象push到queue数组 if(!e) &#123;//e为空的时候，将queue数组属性名称为c的对象删除 delete this.queue[c] &#125; &#125; &#125;; //各种赋值，最后都等于同一个函数 a.alert = a.alert = a.alert = a.delayJsCallBack = a.getIMSI = a.getOsSdk = a.goBack = a.overloadMethod = a.overloadMethod = a.passJson2Java = a.passLongType = a.retBackPassJson = a.retJavaObject = a.testLossTime = a.toast = a.toast = function() &#123; var f = Array.prototype.slice.call(arguments, 0); if(f.length &lt; 1) &#123; throw &quot;HostApp call error, message:miss method name&quot; &#125; var e = []; //此段判断，然后赋值 for(var h = 1; h &lt; f.length; h++) &#123; var c = f[h]; var j = typeof c; e[e.length] = j; if(j == &quot;function&quot;) &#123; var d = a.queue.length; a.queue[d] = c; f[h] = d &#125; &#125; //将匿名对象&#123;method: f.shift(),types: e,args: f&#125;转换成json字符串并用浏览器弹出确认可输入框，然后取得输入框的值json序列化为js对象 var g = JSON.parse(prompt(JSON.stringify(&#123; method: f.shift(), types: e, args: f &#125;))); if(g.code != 200) &#123; throw &quot;HostApp call error, code:&quot; + g.code + &quot;, message:&quot; + g.result &#125; return g.result &#125;; //获取a的属性值，然后循环 Object.getOwnPropertyNames(a).forEach(function(d) &#123; var c = a[d]; //判断赋值 if(typeof c === &quot;function&quot; &amp;&amp; d !== &quot;callback&quot;) &#123; a[d] = function() &#123; //concat 连接两个数组 return c.apply(a, [d].concat(Array.prototype.slice.call(arguments, 0))) &#125; &#125; &#125;); b.HostApp = a; console.log(&quot;HostApp initialization end&quot;) &#125;)(window);//闭包函数默认执行，然后赋给window。这样window.b就可以执行了 b.HostApp就是执行a的内容，但是a具体处理逻辑不对外开放，避免外部污染a内部逻辑 代码不难，可以自行理解，其中回调函数被封装在了a对象里面，确保android端可以通过webview.loadUrl()执行回调。android端回调js代码如下： 1javascript:HostApp.callback(0, 0 ,&quot;call back haha&quot;); Android提供的每一个js方法都对应一个JsCallback对象，Android就可以通过JsCallback对象来生成并执行回调js的代码。这种方式通过动态注入js的方式则非常方便，但也有一定限制，比如Android提供的方法必须是static修饰的，且方法第一个参数必须为WebView,不过这不影响使用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI模型，TLS/SSL 及 HTTPS]]></title>
    <url>%2F2016%2F06%2F20%2Fosi-tlsssl-https%2F</url>
    <content type="text"><![CDATA[上回我们白话了密码学中的两种算法，对称加密算法和非对称加密算法，我们有了这两种算法，我们就要将他们应用到实际生活中，就像我们学会了99乘法表，就可以让我们在实际生活中快速的计算啦！ 所以本节课程的先决条件就是，看并掌握我之前白话的这篇文章：对称加密算法vs非对称加密算法。 我们先从互联网开始说起，说到互联网我们就不得不提一下计算机，因为计算机是互联网组成的一个很重要的部分，我们要想使用互联网进行交流就必须使用计算机(注意！我这里的“计算机”是一个统称，爱钻牛角尖的童鞋，不要说，除了计算机还有手机啊，ipad啊，智能手表啊！！！！恩，好了，别闹了)。 然后问题来了，要想形成互联网，计算机和计算机之间就必须相连起来(废话！),于是我们就有了“网线”，当然这里的“网线”也是泛指，因为现在大家家里都用的是无线网！不过无论有线网还是无线网，他们都是通过“物理”途径进行传播信号的！有了这些“联系”，我们计算机和计算机之间有了传递信息的“途径”了，但是！这里仅仅是提供了一个途径，但是如果想让计算机之间彼此了解传输的信息，那么我们必须定义一系列的协议，这些协议是计算机之间都能够明白的，同时发送和接受要严格按照协议去做！就像张三是中国人和王石头是印度人，他们俩要想交流，就要先建立一个途径，无论是加qq还是发邮件，同时他们俩还得说一样的话，不能张三说中国话，王石头说印度话。 所以，这就是好多互联网协议的来历，比如IPv4, IPv6, TCP,UDP,HTTP,FTP,SMTP,TLS/SSL,HTTPS等等。 那么我们再来想一下，比如，张三想通过QQ发送给李四一句“踢球去不？”，那么谁来将我们发出去的信息转换成协议规定的形式呢？QQ这个软件？操作系统？网卡？路由器？网线？还是我们的ISP(网络服务提供商，你可以理解成电信，移动，网通等等)。 其实，这些都会涉及到，所以即使你简简单单的发送一句“踢球去不？”需要涉及到这么多内容，所以，这里要引入一个模型，叫做OSI模型，全称“开放式系统互联通信参考模型”（英语：Open System Interconnection Reference Model）。 这个模型是干嘛的呢？就是将计算机和计算机之间信息交换“概念化”成不同的层次，每层分别有它自己的“实现”，每层有它自己的任务，同时“向上”提供“抽象”的“接口”供上层使用。一般分成7层或者5层。为了简便期间我这里按照5层架构说一下，这五层分别是： 应用层(application layer) 传输层(transport layer) 网络层(network layer) 数据链路层(data link layer) 物理层(physical layer) 回到我们的例子，当张三用QQ向李四发送一条信息时，首先QQ属于应用层，应用层需要将信息发送给传输层，传输层经过处理之后传给网络层，以此类推传给物理层，这样一层层向下“包装”，每层有对应的协议，这样最后通过物理层传出去，传到李四的物理层，然后李四那边通过一层层向上按照协议“解包”，最后到应用层，传到李四的qq里。 所以每层都有相对应的协议比如我们的物理层和数据链路层通过无线网传输使用的802.2传输协议，有线网的Ethernet(以太网)传输协议，还有网络层的IPv4, IPv6协议，传输层的TCP, UDP协议，而我们熟悉的HTTP协议其实属于应用层，所以HTTP是建立在TCP/IPv4或v6/以太网基础上进一步细化用于传输“超文本”信息的协议，比如FTP也属于应用层，也是在下面各层协议基础上进行细化，专门用于“文件传输”的协议。 大家可以看到，协议越往上越具体，越往下约抽象，其实计算机技术的发展就是一层层的向上抽象，这样上层的可以直接使用下层的“成果”(API)！ 我们再来说一下TLS/SSL，SSL(secure sockets layer)是TLS(transport layer security)的前身，为什么将他们合起来的，大家可以理解成都属于同一东西的不同阶段吧，比如该协议之前叫SSL后来改名成TLS了。 为什么要有这种协议呢？因为HTTP是使用明文传输，随着网络的发展，安全性越来越重要，所以大家就要想办法让传输更加安全，同时使用密码学的成果，利用“非对称加密算法”的思想以及OSI模型，来对HTTP的信息进行加密。 因为上面我们说了，根据OSI模型，如果向外传输信息就是要从上到下挨个层进行，TLS/SSL也是位于应用层，所以为了加密HTTP的内容，那么TLS/SSL必须位于HTTP下面，可以看成这样： 12345HTTPTLS/SSLTCPIp.. 信息从HTTP经过TLS/SSL非对称加密后传出去，而在接收方，接收到信息是需要一层层向上进行，经过每层的“解包/解密”，最终通过HTTP转换成超文本信息。 所以HTTPS 就是 “HTTP内容向下传输的时候加了一层TLS/SSL加密”，仅此而已，这样，我们就可以实现，使用HTTP协议进行互联网信息传播的时候，对信息进行加密处理了，相信大家已经对非对称加密算法有一定了解了。比如说我们通过HTTPS连接某银行网站，这样我们就可以将我们的密码通过银行给我们的公钥进行加密后发送给银行，而避免了在传输过程中被他人偷看的可能，因为即使他们讲我们的密文盗走，也无法解密，只有银行网站可以解密，为什么？因为只有银行拥有与我们使用“公钥”加密相对的那个“私钥”。 但是同样的问题，就是我们怎么知道我们使用的公钥就是银行给我们的呢？即使我们所访问的域名和银行的域名一致，因为黑客完全可以通过修改我们本地的hosts文件，或者入侵dns，将域名映射到黑客的服务器。 所以，这就是CA(certificate authority)，数字证书，数字签名，公钥基础设施(PKI)等等名词的来历。 下回再白话。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称加密算法 VS 非对称加密算法]]></title>
    <url>%2F2016%2F06%2F13%2Fsymmetric-key%20algorithm-vs-public-key-cryptography%2F</url>
    <content type="text"><![CDATA[对称加密算法(Symmetric-key algorithm)和非对称加密算法(asymmetric key encryption algorithm)只不过就是密码学(encryption)中的两种解密算法罢了，什么是算法，你就可以理解成为是一种规则吧，这种规则可以将信息从一种形式转变成另一种形式，不懂没关系，继续往下看。 对称加密首先，让我们先从一个情景开始讲起，想当初我们在初中，高中，甚至于大学，每次考试都有人在试图如何更加隐蔽的作弊！那大家都想了什么方法呢？比如张三学习比李四好，李四就想在考试的时候让张三“帮助”一下自己，当然，他们俩不可能像我们平常对话一样说，第一题选A，第二题选B等等，为什么？因为监考老师明白他俩在谈论什么，也就是说这种沟通交流方式属于“明文”，所以李四就想：“我需要发明一种，只有我和张三明白的交流方式”，那李四做了什么呢？恩，李四去找张三说：“当我连续咳嗽三声的时候你看我，然后如果我摸了下左耳朵，说明你可以开始给我传答案了，如果没反应，那说明我真的是在咳嗽。。。。”， 然后，怎么传答案呢？很简单，“你摸左耳朵代表A, 摸右耳朵代表B，左手放下代表C，右手放下代表D”，好了，这就是他们的“算法(规则)”，将信息的一种形式(A,B,C,D)，这里我们称为“明文”，转换成了另一种形式(摸左耳朵，摸右耳朵，放左手，放右手)，这里称为“密文”，经过这种转换，很显然监考老师不会明白这些“密文”，这样，张三和李四就通过“密文”的形式实现了信息的交换。 其实，密码学不就是为了人们更好的加密传输么？有很多学者，科学家成年累月的工作，为的就是改进或者发明更好的加密算法，让这些加密算法加密的文本难以破解，达到数据安全传输的目的。 OK，回归正题，上面这个“作弊”的例子，其实就是一种对称加密算法！好了，我们来看一下对称加密算法的定义(来源:wikipedia)： 对称密钥加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一这里我想说一点的是，wikipedia的把Symmetric-key algorithm中文翻译是 对称密钥加密，我不想把这个key翻译成密钥，因为key仅仅是一个“钥”，这里翻译成密钥会让大家对后面所说的“公钥”，“密钥”，“私钥”等等的概念弄混，好了，所以我还是比较喜欢称之为“对称加密算法”，而后面说又称“私钥”加密，共享“密钥”，这里，“私钥”就等于“密钥”，没有任何区别，英文是“private key”。 ok，我们将定义结合我们前面的例子对应一下，“这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥”，其实在我们例子中，密钥就是“将(A,B,C,D)转换成(摸左耳朵，摸右耳朵，放左手，放右手)”这么一个规则。“实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。” 这句话很好理解了吧，密钥是张三和李四间共同的秘密！只有他俩事先知道。 所以，为什么叫对称加密呢，你可以这么理解，一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下： 1明文 &lt;-&gt; 密钥 &lt;-&gt; 密文 这样看，是不是感觉对称比较好理解了。ok，那么我们现在有哪些现成的对称加密算法可以用么？当然有： 1常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 想深入了解的同学，可以自行查阅资料了。 非对称加密我们再来说说非对称加密，非对称加密是一种比对称加密更加优秀的加密算法，当然算法有利有弊，对称加密速度快但是安全性相对于非对称加密来说低，为什么呢，你想啊，要想使用对称加密，那么分享信息的各个个体之间都需要分享这个密钥，比如你们1000个人之间都使用同一个密钥进行密文传输，只要其中一个人密钥被盗窃了，那么整体加密的信息将都被破解了。好了，那么我们开始说说非对称加密。 就从上面提到的这个对称加密的缺点开始，怎么做到即时一个人的密钥被盗窃了，最起码保证你给其他人发送密文不被破解。于是，人们就想出了这么个办法，首先，我们停止分享共同的密钥，因为上面的bug就是来源于共享一个密钥，那么怎么办呢？每个人生成一个“私钥-公钥”对，这个私钥需要每个人自行进行保护！公钥可以随便分享，后面详细说，同时，生成的这个“私钥-公钥”对还有个强大的功能就是，使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密！ 好了，比如说张三生成了他自己的一个“私钥-公钥”对，叫做“张三私钥-张三公钥”，李四生成了他自己的一个“私钥-公钥”对，叫做“李四私钥-李四公钥”，之前我们说过私钥要每个个体自己进行保存，公钥可以随便分享，目的是为什么呢？是为了加密信息！ 比如，李四想给张三发送密文。于是李四开始给张三发QQ 123456李四：“hi哥们，我想给你发个密文，把你的公钥给我发过来用用。”张三：“没问题的，这是我的公钥：d#8yHE8eU#hb*!neb，用这个公钥加密你的信息后给我发过来吧”李四：“这是我想对你说的话： *&amp;#@uehuu(**#eehu&amp;$##bfeu&amp;&amp;” 恩？你是不是有点疑问呢？咳咳，李四这是作死的节奏？为什么公开问公钥？不怕被网警查水表？哈哈，非对称解密算法的威力就在这里！无所谓！随便谁截取！我们上面说了，公钥可以随意分发，所以即使别人截取了，也只是知道该公钥而已，但是要是想解密使用该公钥加密的密文！只有一个人可以办得到！就是张三！ 为什么？李四使用张三的公钥加密的信息，只有张三的公钥所对应的私钥，这里就是“张三私钥”，该私钥才可以解密！所以，没有张三私钥的第三方即时截取了这些密文，也破解不了！或者更严格的说在有限时间内比如说几千年内是暴力破解不出的！ 懂了吧？所以网警们哭了，本以为想监视他们的对话，可惜一无所获！ 我们来看看非对称加密的官方定义： 公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。hmm。。这个定义有点绕，不过就是说，要想使用非对称加密算法，首先要有一对key，一个被称为private key私钥，一个成为public key公钥，然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密，也就是说，只要你自己保存好你的private key，就能确保，别人想给你发的密文不被破解，所以你不用担心别人的密钥被盗，没关系。 正因为，这种加密是单向的，所以被称为非对称加密算法。 1这种加密算法应用非常广泛，SSH, HTTPS, TLS，电子证书，电子签名，电子身份证等等。 这篇文章先写到这里，接下来我将像大家挨个介绍这些加密算法的应用，不过我在这里先埋个伏笔，上面我提到的李四和张三发qq，即时使用非对称加密算法，大家有没有发现仍然有哪些隐患呢？ 给点提示，比如说，某个网警想知道到底李四要给张三发什么信息？网警想破解李四的密文，那么网警有什么办法可以获得李四要发的信息呢？很显然获得密文直接暴力破解是不可能的! 小提示，网警可以冒充张三！！！！发送给李四“网警的公钥”，而不是“张三的公钥”，那么当李四收到该公钥的时候，就不假思索的使用该公钥加密了他的信息，然后毫不犹豫的将加密的密文发了过去，然后网警得意的笑了。 所以，问题在哪呢？这就是数字签名和数字证书的来历！我们下回接着白话。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Facebook Redex 实现 Android APK 的压缩和优化]]></title>
    <url>%2F2016%2F05%2F13%2Foptimizing-android-bytecode-with-redex%2F</url>
    <content type="text"><![CDATA[随着世界各地越来越多的人开始登录Facebook，我们有越来越大的责任保证她的快捷使用性。在发展中地区尤为如此，其中旧设备在市场上滞留的时间变长，人们对新设备的升级周期同样页边长了。我们希望确保我们的程序在所有主要移动平台上改进性能的可能的方法。 Android是我们最大的平台之一，它也是具有很大的多样性设备的移动平台。在这些设备上的任何性能或效率改进都可以更好地为全世界数百万人的体验到。 今天，我们想分享一些我们的努力，通过一个我们称之为Redex的项目来优化Android的Java字节码。Redex是一个用于优化Android .dex文件的管道。通过应用一系列可定制的转换，使得在源.dex在被合并到APK之前被优化。 在我们的优化项目开始时，我们决定做最优化的最佳优化切入点是在创建.dex文件之后和将.dex文件组装到APK之前。在字节码级别（而不是直接在源代码上）执行我们的优化，这样的优点是，它使我们能够在整个全局的二进制文件上执行类间优化，而不是仅仅执行本地类级别优化。我们选择对dex字节码而不是Java字节码执行变换，因为某些变换只能在DX之后完成。这将类似于C风格编译过程中的后链接阶段，您可以在整个二进制文件中进行全局优化。 我们意识到工程师可能会继续提出新的和创造性的字节码优化随着时间的推移。Facebook工程师往往快速移动，所以我们想要构建一个能从多个工程师工作的许多优化的好处。我们将我们的优化管道组织为一系列阶段，其中“原始”.dex在管道的开始处进入，并且“转换的”.dex在结束处离开。流水线中的每个阶段都可以被认为是一个独立的“优化插件”，它在前一阶段之后捕捉到位置，允许我们将多个不同的，可能无关的变换链接在一起。这使得它从工程角度来说非常灵活，因为多个工程师可以并行地尝试不同的优化，然后只有当它们准备就绪时才将它们插入最终管道。 Redex管道被推广以允许任何种类的.dex变换，但是今天我们要专注于使用Redex来最小化APK中的字节码。 减少字节码在传输应用程序中减少字节码的数量有很多好的方法。在发展中国家，闪存大小通常限于保持设备成本可承受 - 即使是几兆字节，也可以在少于1 GB的存储空间的手机上产生影响。更少的字节也意味着更快的下载时间，更快的安装时间，并降低单元用户的数据使用。最后，较少的字节码通常也转化为更快的运行时性能。所有其他条件相同，较少的字节码意味着更少的执行指令和更少的代码页故障进入内存，这将是资源密集型场景（如应用程序冷启动）的性能改进。 在这个项目的开始，我们开始查看使用默认编译工具链生成的一些原始.dex文件。当我们盯着字节码时，我们开始找到一些我们可以用Redex优化的常见模式。让我们来看看我们添加到管道以减少.dex文件大小的几个优化阶段。 缩小和压缩通常对诸如Javascript和HTML之类的网络语言进行缩小以通过在不改变功能的情况下减少和最小化字符串来减少字节。这些技术在Java中有较好效。 字符串在开发期间对于工程师是非常有价值的 - 例如类路径，源文件的文件路径，函数名等等 - 但是字符串在编译的字节码中实际占用了很多字节。此外，运行时通常不关心这些描述性命名的字符串：它将调用函数“abc（）”就像调用函数“MyFooSuccessCallback（）”一样容易。 因此，我们通常可以用任何（较短的）占位符字符串来替换长的人类可读的字符串。这减少了专用于字符串而不影响应用程序功能的字节数。 There are some qualifications to this, though. Source file paths, while not explicitly necessary for code execution at runtime, are extremely useful for engineers when something goes wrong. If we were to replace them with some short but random placeholder string, or even to strip them out entirely, we’d lose an important hint when following up on bug reports. 和纯缩小一样，我们可以通过我们的.dex并用一个较短的占位符字符串替换文件路径字符串。然而，我们需要保持反向映射到原始字符串，所以我们可以重建文件的路径来源，当我们需要它们，例如在错误报告。我们实际上不需要在APK本身中发送这个反向映射，因为对于所有实际目的，它将永远不会被现场的机器代码使用，所以这最终是我们的发运APK大小的改进。 内联内联是用于将被调用函数的功能移动到其调用函数中以减少函数调用的开销而不改变功能的一般技术。除了潜在地提高代码执行的性能之外，如果正确执行，这也可能导致尺寸减小。但是，如果操作不当，内联可以很容易地增加最终二进制文件的大小，而不是。 良好的软件工程实践通常鼓励适当地封装范围和类责任。虽然这些策略在工程过程中很重要，但它们也可以在最终的字节码中留下一些优化机会。 最简单的例子之一是包装函数。这些通常是添加的小功能，为工程师提供更简单的类API或调整功能以接受不同的参数列表。这也可能包括简单的访问器函数（setter / getter），这些函数必须包含在类API中，但在运行时可能永远不会被调用。在类文件的初始编译期间，不是立即显而易见哪些函数是多余的，但是当我们有我们的初始.dex文件时，我们可以看到哪些全局优化可用。 此外，对于调用其他类的类，可能会有一些包装器函数调用其他包装函数 - 我们应该删除中间人。在许多情况下，这正是我们所做的。每当我们将一个函数内联到另一个函数中时，我们可以减少与函数跳转相关联的开销（和字节码）。 自然，这需要非常仔细地做。很多时候，仍然有一些值由访问器或包装函数提供 - 运行时访问检查或多态性 - 但在实例中，当我们可以确保这种技术不会导致任何正确性错误，那么上行是字节码减少。 还有另一种情况，内联可能是可能的。说一个父进程调用一个子函数，但需要先绕过一个中间函数。这可能是类型协方差检查的情况，其中我们要运行一些简单的运行时检查。与前面的例子不同，这个中间函数可能是微不足道的，但是我们不能完全剥离它; 它在运行时对我们有用。然而，这些函数中的许多都很小，以至于调用它们的字节码开销几乎与函数本身一样大。 在一个简单的情况下，我们在父函数和子函数之间有一个1：1的调用关系，我们可能只是将迂回函数内联到父函数或子函数中，如上所述。 然而，当父和子之间的调用关系是1：N或N：1 - 甚至N：N时，这变得更复杂。在这些情况下，鲁莽内联可以增加我们的二进制大小，而不是减少它！在这些情况下的伎俩是找出是否将绕行功能嵌入父节点或子节点（ren），或者是否没有改进的机会，我们应该完全中止内联。这些是在编译时基本不可能做出的决定，但可以通过分析.dex文件的全局状态来完成。 消除冗余代码在任何大型项目中，死亡或不可达代码都不可避免地累积在源代码中。删除死代码通常是一个非常简单的技术，用于减少二进制大小，没有任何其他缺点。 在某些方面，死代码消除类似于标记和清除垃圾回收。如果你开始一些你知道可以访问的入口点，例如清单文件中定义的主要活动，你可以运行分支和函数调用。在遍历函数调用的这个图表时，我们可以标记沿途访问的每个函数。在我们遍历了每个可能的分支和函数调用之后，我们可以假设所有未标记的函数都是可以安全删除的死代码。 这种用于去除死代码的技术在理论上是简单的，但是还存在一些需要考虑的实际复杂性。在处理反射时，你需要小心，因为在构建时可能不明显函数被间接调用。您还需要注意通过布局或其他资源引用的类和函数 - 仅分析Dalvik字节码本身不足以识别类中的所有不同入口点。这些例子需要他们自己的专门技术来识别死代码，但从根本上说，它们的功能类似于简单的情况。 摘要我们希望这给了你一个Redex提供的品味。在这篇文章中，我们专注于减少字节码大小，但我们一直在努力的其他一些令人兴奋的优化管道，我们希望在未来分享。在此之前，敬请期待！ 感谢David Alves，David Tarjan和其他人帮助写这篇文章。 英文原文]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie 和 Session 的区别]]></title>
    <url>%2F2016%2F03%2F18%2Fdiff-cookie-session%2F</url>
    <content type="text"><![CDATA[由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 所以，总结一下： 12Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种常用加密算法比较]]></title>
    <url>%2F2015%2F12%2F07%2Fdiff-of-some-cipher%2F</url>
    <content type="text"><![CDATA[由于计算机软件的非法复制，通信的泄密、数据安全受到威胁，解密及盗版问题日益严重，甚至引发国际争端，所以在信息安全技术中，加密技术占有不可替代的位置，因此对信息加密技术和加密手段的研究与开发，受到各国计算机界的重视，发展日新月异。现在我们就几种常用的加密算法给大家比较一下。 DES加密算法DES加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长度是56位，加密解密用同一算法。DES加密算法是对密钥进行保密，而公开算法，包括加密和解密算法。这样，只有掌握了和发送方相同密钥的人才能解读由DES加密算法加密的密文数据。因此，破译DES加密算法实际上就是搜索密钥的编码。对于56位长度的密钥来说，如果用穷举法来进行搜索的话，其运算次数为256。 随着计算机系统能力的不断发展，DES的安全性比它刚出现时会弱得多，然而从非关键性质的实际出发，仍可以认为它是足够的。不过，DES现在仅用于旧系统的鉴定，而更多地选择新的加密标准。 AES加密算法AES加密算法是密码学中的高级加密标准，该加密算法采用对称分组密码体制，密钥长度的最少支持为128、192、256，分组长度128位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的区块加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。 AES加密算法被设计为支持128／192／256位（/32=nb)数据块大小（即分组长度）；支持128／192／256位（/32=nk)密码长度，，在10进制里，对应34×1038、62×1057、1.1×1077个密钥。 RSA加密算法RSA加密算法是目前最有影响力的公钥加密算法，并且被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数宇签名的算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA加密算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 Base64加密算法Base64加密算法是网络上最常见的用于传输8bit字节代码的编码方式之一，Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在JAVAPERSISTENCE系统HIBEMATE中，采用了Base64来将一个较长的唯一标识符编码为一个字符串，用作HTTP表单和HTTPGETURL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 MD5加密算法MD5为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。对MD5加密算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成—个128位散列值。 MD5被广泛用于各种软件的密码认证和钥匙识别上。MD5用的是哈希函数，它的典型应用是对一段信息产生信息摘要，以防止被篡改。MD5的典型应用是对一段Message产生fingerprin指纹，以防止被“篡改”。如果再有—个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。MD5还广泛用于操作系统的登陆认证上，如UNIX、各类BSD系统登录密码、数字签名等诸多方。 SHA1加密算法SHA1是和MD5一样流行的消息摘要算法。SHA加密算法模仿MD4加密算法。SHA1设计为和数字签名算法（ＤＳＡ）一起使用。 SHA1主要适用于数字签名标准里面定义的数字签名算法。对于长度小于2“64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1不可以从消息摘要中复原信息，而两个不同的消息不会产生同样的消息摘要。这样，SHA1就可以验证数据的完整性，所以说SHA1是为了保证文件完整性的技术。 SHA1加密算法可以采用不超过264位的数据输入，并产生一个160位的摘要。输入被划分为512位的块，并单独处理。160位缓冲器用来保存散列函数的中间和最后结果。缓冲器可以由5个32位寄存器（A、B、C、D和E）来表示。SHA1是一种比MD5的安全性强的算法，理论上，凡是采取“消息摘要”方式的数字验证算法都是有“碰撞”的——也就是两个不同的东西算出的消息摘要相同，互通作弊图就是如此。但是安全性高的算法要找到指定数据的“碰撞”很困难，而利用公式来计算“碰撞”就更困难一目前为止通用安全算法中仅有MD5被破解。 加密算法是密码技术的核心，以上这些加密算法是常用的加密算法，而这些算法有些已经遭到破译，有些安全度不高，有些强度不明，有些待进—步分析，有些需要深入研究，而神秘的加密算法世界，又会有新的成员加入，期待更安全的算法诞生。 转载 来自于 http://blog.csdn.net/achejq/article/details/9135209]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据库加密-SQLCipher集成]]></title>
    <url>%2F2015%2F12%2F05%2Fsqlcipher-for-android-application-integration%2F</url>
    <content type="text"><![CDATA[缘由我们都知道使用SQLite来存储数据却存在着一个安全问题，就如微信之前数据库也是没加密的，后来才进行了加密。大多数的Android手机都是Root过的，而Root过的手机都可以进入到/data/data/&lt;package_name&gt;/databases目录下面，在这里就可以查看到数据库中存储的所有数据。如果是一般的数据还好，但是当涉及到一些账号密码，或者聊天内容的时候，我们的程序就会面临严重的安全漏洞隐患。那么今天，就让我们一起研究一下如何借助SQLCipher来解决这个安全性问题。 SQLCipher是一个在SQLite基础之上进行扩展的开源数据库，它主要是在SQLite的基础之上增加了数据加密功能，如果我们在项目中使用它来存储数据的话，就可以大大提高程序的安全性。SQLCipher支持很多种不同的平台，这里我们要学习的自然是Android中SQLCipher的用法了。 社区版集成添加以下项进行dependencies到app/build.gradle文件： 1compile &apos;net.zetetic:android-database-sqlcipher:3.3.1@aar&apos; 商业版集成本教程将介绍将Android的SQLCipher的二进制文件集成到现有的Android应用程序中。本教程假定开发人员具有用于Android商业二进制文件的最新SQLCipher。 我们需要将各种库文件复制到我们应用程序的根目录中。执行以下命令： 123456% unzip sqlcipher-for-android-v3.3.1.zip% mkdir -p app/libs% cp sqlcipher-for-android-v3.3.1/sqlcipher.jar app/libs% cp -r sqlcipher-for-android-v3.3.1/armeabi \ sqlcipher-for-android-v3.3.1/armeabi-v7a \ sqlcipher-for-android-v3.3.1/x86 app/src/main/jniLibs/ 最后，下面的添加到app/build.gradle该文件中的dependencies部分： 1compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) 应用程序使用接下来，我们将初始化SQLCipher，然后创建数据库文件插入记录。特别要注意的是导入包net.sqlcipher.database.SQLiteDatabase替代android.database.sqlite.SQLiteDatabase以及调用SQLiteDatabase.loadLibs(this)。请注意在其他任何数据库操作之前，先调用SQLiteDatabase.loadLibs(this)加载libs。 1234567891011121314151617181920212223242526package com.demo.sqlcipher;import java.io.File;import net.sqlcipher.database.SQLiteDatabase;import android.app.Activity;import android.os.Bundle;public class HelloSQLCipherActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); InitializeSQLCipher(); &#125; private void InitializeSQLCipher() &#123; SQLiteDatabase.loadLibs(this); File databaseFile = getDatabasePath(&quot;demo.db&quot;); databaseFile.mkdirs(); databaseFile.delete(); SQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(databaseFile, &quot;test123&quot;, null); database.execSQL(&quot;create table t1(a, b)&quot;); database.execSQL(&quot;insert into t1(a, b) values(?, ?)&quot;, new Object[]&#123;&quot;one for the money&quot;, &quot;two for the show&quot;&#125;); &#125;&#125; This’s all! Detail https://github.com/sqlcipher/android-database-sqlcipher。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android冷启动时间优化]]></title>
    <url>%2F2015%2F12%2F03%2Fandroid-cold-start%2F</url>
    <content type="text"><![CDATA[原理冷启动时间是指当用户点击你的app那一刻到系统调用Activity.onCreate()之间的时间段。在这个时间段内，WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局。 冷启动时间优化知道了Android冷启动时间的原理之后，就可以通过一些小技巧来对冷启动时间进行优化，从而让你app加载变得”快“一些（视觉体验上的快）。我们可制作一个启动Activity的背景样式的.9图片，然后把这个.9图片做为windowBackground。 这里推荐使用 MaterialColdStart 这个库来制作我们.9图片。 首先git clone https://github.com/DreaminginCodeZH/MaterialColdStart 由于该库中引用了子模块 AndroidSVGScripts, 所以我们需要把该子模块也update下来，否则无法运行。但是作者定义该子模块的时候使用了ssh协议，所以会导致我们无法update，这里我们要先修改.gitmodules文件将里面所有的git@github.com:改为https://github.com/就可以了，然后执行git submodule init 和 git submodule update命令就可在把子模块update下来了 在生成.9图片之前，我们还需要根据自己的项目修改生成.9图片的配置文件，打开colors.conf文件，可以配置statusbar、actionbar、background的颜色等，修改raw-xxx目录下的window_background_statusbar_toolbar_tab.9.shsvg.conf文件可以配置statusbar、actionbar的高度等 最后执行./gen-png.sh命令，就可以在gen目录下生成我们所需的.9图片了 图片制作好之后，我们就可以用它做为app冷启动阶段的预览元素，如下设置： 为启动的Activity自定义一个Theme 123&lt;style name=&quot;AppTheme.Launcher&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/window_background_statusbar_toolbar_tab&lt;/item&gt;&lt;/style&gt; 将新的Theme应用到设置到AndroidManifest.xml中 123456789&lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot;@style/AppTheme.Launcher&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 由于给MainActivity设置了一个新的Theme，这样做会覆盖原来的Theme，所以在MainActivity中需要设置回原来的Theme 1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // Make sure this line comes before calling super.onCreate(). setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); &#125;&#125; 效果预览第一张是启用了冷启动优化，第二张是没有启用冷启动优化。 from http://blog.waynell.com/2015/11/17/android-cold-start/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米电视的红外控制]]></title>
    <url>%2F2015%2F11%2F21%2Fmi-tv-infrared-control-on-android%2F</url>
    <content type="text"><![CDATA[原理红外遥控的发射电路是采用红外发光二极管来发出经过调制的红外光波；红外接收电路由红外接收二极管、三极管或硅光电池组成，它们将红外发射器发射的红外光转换为相应的电信号，再送后置放大器。 发射机一般由指令键(或操作杆)、指令编码系统、调制电路、驱动电路、发射电路等几部分组成。当按下指令键或推动操作杆时，指令编码电路产生所需的指令编码信号，指令编码信号对载波进行调制，再由驱动电路进行功率放大后由发射电路向外发射经调制定的指令编码信号。 接收电路一般由接收电路、放大电路、调制电路、指令译码电路、驱动电路、执行电路(机构)等几部分组成。接收电路将发射器发出的已调制的编码指令信号接收下来，并进行放大后送解调电路，解调电路将已调制的指令编码信号解调出来，即还原为编码信号。指令译码器将编码指令信号进行译码，最后由驱动电路来驱动执行电路实现各种指令的操作控制（机构）。 不说那么多废话了，看代码吧。。。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ConsumerIrActivity extends Activity &#123; private static final String TAG = &quot;ConsumerIrTest&quot;; private TextView mFreqsText; // Android4.4之后 红外遥控ConsumerIrManager private ConsumerIrManager mCIR; @SuppressLint(&quot;InlinedApi&quot;) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.consumer_ir); // 获取系统的红外遥控服务 mCIR = (ConsumerIrManager) getSystemService(Context.CONSUMER_IR_SERVICE); initViewsAndEvents(); &#125; private void initViewsAndEvents() &#123; findViewById(R.id.send_button).setOnClickListener(mSendClickListener); findViewById(R.id.get_freqs_button).setOnClickListener(mOnClickListener); mFreqsText = (TextView) findViewById(R.id.freqs_text); &#125; View.OnClickListener mSendClickListener = new View.OnClickListener() &#123; @TargetApi(Build.VERSION_CODES.KITKAT) public void onClick(View v) &#123; if (!mCIR.hasIrEmitter()) &#123; Log.e(TAG, &quot;未找到红外发身器！&quot;); return; &#125; // 开关机指令 int[] pattern = &#123; 36,23,21,21,23,55,23,55,23,21,23,55,23,22,23,54,23,22,23,55, 23,55,23,402,38,22,22,22,23,55,23,55,23,21,23,55,23,22,22,54,23,22,23,55,23, 55,22,402,38,21,23,22,23,55,23,55,23,21,23,55,23,21,23,55,23,22,23,55,23,55,22 &#125;; // 在38.4KHz条件下进行模式转换 mCIR.transmit(38400, pattern); &#125; &#125;; @SuppressLint(&quot;NewApi&quot;) View.OnClickListener mOnClickListener = new View.OnClickListener() &#123; public void onClick(View v) &#123; StringBuilder b = new StringBuilder(); if (!mCIR.hasIrEmitter()) &#123; mFreqsText.setText(&quot;未找到红外发身器！&quot;); return; &#125; // 获得可用的载波频率范围 ConsumerIrManager.CarrierFrequencyRange[] freqs = mCIR.getCarrierFrequencies(); b.append(&quot;IR Carrier Frequencies:\n&quot;);// 红外载波频率 // 边里获取频率段 for (ConsumerIrManager.CarrierFrequencyRange range : freqs) &#123; b.append(String.format(&quot; %d - %d\n&quot;,range.getMinFrequency(), range.getMaxFrequency())); &#125; mFreqsText.setText(b.toString());// 显示结果 &#125; &#125;;&#125; 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt;&lt;Button android:id=&quot;@+id/send_button&quot; android:text=&quot;@string/ir_send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;Button android:id=&quot;@+id/get_freqs_button&quot; android:text=&quot;@string/ir_get_freqs&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;ScrollView android:id=&quot;@+id/freqs_text_scroll&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; &gt; &lt;TextView android:id=&quot;@+id/freqs_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;3dp&quot; android:paddingRight=&quot;3dp&quot; /&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 小米TV控制指令1234567891011开关机 36,23,21,21,23,55,23,55,23,21,23,55,23,22,23,54,23,22,23,55,23,55,23,402,38,22,22,22,23,55,23,55,23,21,23,55,23,22,22,54,23,22,23,55,23,55,22,402,38,21,23,22,23,55,23,55,23,21,23,55,23,21,23,55,23,22,23,55,23,55,22上 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,34,22,33,23,45,22,55,23,475,39,22,23,45,23,22,23,33,23,45,23,22,23,22,23,33,23,34,23,44,23,56,23,476,38,22,23,44,23,21,23,33,23,44,23,21,23,22,23,33,23,33,23,44,23,56,23下 36,23,23,43,23,22,23,32,23,44,23,22,23,21,23,33,23,44,23,43,23,22,23,491,38,22,23,43,23,22,23,33,22,44,23,22,23,21,23,33,23,44,23,43,23,22,23,492,38,22,23,43,23,22,23,33,22,43,23,22,23,21,23,33,23,44,23,44,22,22,23左 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,45,23,56,23,33,23,33,23,474,39,22,23,45,22,22,22,33,23,45,22,22,23,22,23,44,23,55,23,34,22,33,23,475,38,22,22,44,23,22,23,34,23,44,23,22,23,21,23,44,23,56,23,33,23,34,23右 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,56,23,22,23,22,23,45,23,497,39,22,23,45,23,22,23,33,23,45,23,22,23,22,23,56,23,22,23,22,23,44,23,498,38,22,23,44,23,22,23,33,23,44,23,21,23,21,23,55,23,21,23,22,22,44,23ok 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,56,23,33,23,21,23,55,23,474,38,22,23,44,23,21,23,33,23,44,23,21,23,22,23,55,23,33,23,22,23,56,23,475,38,22,23,45,23,22,23,33,23,44,23,22,23,22,23,56,23,33,23,22,23,55,23音量+ 36,23,21,43,23,22,23,32,23,44,23,22,23,21,23,55,23,44,23,21,23,22,23,491,37,22,21,43,23,22,23,32,23,44,23,22,23,21,23,55,23,44,23,21,23,22,23,491,37,22,21,43,23,22,23,32,23,44,23,22,23,21,23,55,23,44,23,21,23,22,23音量- 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,56,23,56,23,22,23,33,23,479,39,22,23,45,23,22,23,33,23,45,23,22,23,22,23,56,23,56,23,22,23,33,23,480,38,22,23,44,23,21,23,33,23,44,23,22,22,22,23,55,23,55,23,21,23,33,23菜单 36,23,23,44,23,22,23,33,23,44,23,22,23,22,23,33,23,22,23,44,23,45,23,3955返回 36,23,23,43,23,22,23,32,23,44,23,22,23,21,23,33,23,55,23,44,22,33,23,470,38,22,22,43,23,22,23,32,23,44,23,22,23,21,23,33,23,55,23,44,22,33,23,470,38,22,23,43,23,22,23,33,22,44,23,22,23,21,23,33,23,55,23,44,22,32,23首页 36,23,21,43,23,22,23,32,23,44,23,22,23,21,23,44,23,21,23,33,23,44,23,492,38,21,23,44,23,22,23,32,23,44,23,22,23,21,23,44,23,21,23,33,23,44,23,492,38,21,23,44,23,22,23,32,23,44,23,22,21,21,23,44,23,21,23,33,23,44,23]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Flux Architecture]]></title>
    <url>%2F2015%2F11%2F13%2Fusage-of-flux-on-android%2F</url>
    <content type="text"><![CDATA[要为安卓应用找到一个好的架构不是一件容易的事情。谷歌似乎不太在乎这个事情，因此在设计模式上，除了Activity 生命周期管理之外，再也没有官方的推荐。 但是，为你的应用打造一个架构是非常重要的。不管你是否喜欢，任何应用最终都会有一个架构。因此你最好是成为一个架构的奠基人，而不是等着它出现。 Clean Architecture目前的趋势是采用Uncle Bob在2012年对web应用提出的建议： Clean Architecture。 但是我发现Clean Architecture对于绝大多数安卓应用来说都有点过度设计了。 通常移动应用要比web应用的生命短。移动端技术的发展太快，以至于今天发行的app可能在一年后已经完全过时。 移动应用所做的事情很少。绝大多数的用例都只是数据信息流的消费。从API获取数据，显示数据给用户，很少有输入与写入。 所以它的业务逻辑并不复杂。至少不如后端一样的复杂。虽然你要处理很多平台上的问题：内存，存储，暂停，恢复，网络，定位等等，但是这些都不是业务逻辑。所有app都有这些东西。 因此，绝大多数app似乎都无法从类似于复杂的分层或者工作执行优先级队列中获益。 他们也许只是需要一种组织代码的简单方式，能高效的一起工作，更容易的发现bug。 Flux ArchitectureFlux Architecture 被Facebook使用来构建他们的客户端web应用。跟Clean Architecture一样，它不是为移动应用设计的，但是它的特性和简单可以让我们很好的在安卓项目中采用。 要理解Flux，有两个关键的特点 数据流总是单向的一个单向的数据流 是 Flux 架构的核心，也是它简单易学的原因。就如下面讨论的，在进行应用测试的时候，它提供了非常大的帮助。应用被分成三个主要部分： View: 应用的界面。这里创建响应用户操作的action。 Dispatcher: 中心枢纽，传递所有的action，负责把它们运达每个Store。 Store: 维护一个特定application domain的状态。它们根据当前状态响应action，执行业务逻辑，同时在完成的时候发出一个change事件。这个事件用于view更新其界面。 这三个部分都是通过Action来通信的：一个简单的基本对象，以类型来区分，包含了和操作相关的数据。 Flux Android 架构在安卓开发中使用Flux设计规范的目的是建立一个在简单性与易扩展易测试之间都比较平衡的架构。 第一步是找到Flux元素和安卓app组件之间的映射。 其中两个元素非常容易找到与实现。 View: Activity o或者Fragment Dispatcher: 一个事件总线（ event bus），在我的例子中将使用Otto，但是其它任何实现都应该是ok的。 Actions Actions也不复杂。它们的实现和POJO一样简单，有两个主要属性： Type: 一个String，定义了事件的类型。 Data: 一个map，装载了本次操作。比如，一个显示用户详情的典型action如下： 123Bundle data = new Bundle(); data.put(&quot;USER_ID&quot;, id); Action action = new ViewAction(&quot;SHOW_USER&quot;, data); Stores这可能是Flux理论中最难的部分。 如果你之前使用过Clean Architecture，你可能难以接受。因为Stores承担了原本被分成多层的责任。 Stores包含了application的状态与它的业务逻辑。它们类似于rich data models但是可以管理多个对象的状态，而不仅仅是一个对象。 Stores响应Dispatcher发出的Action，执行业务逻辑并发送change事件。 Stores的唯一输出是这单一的事件：change。其它对Store内部状态感兴趣的组件必须监听这个事件，同时使用它获取需要的数据。 系统中不再需要任何其它组建去了解application的任何状态信息。 最后，stores必须对外公开一个获取application状态的接口。这样，view元素可以查询Stores然后相应的更新UI。 比如，在一个Pub Discovery App 中，SearchStore被用来跟踪被搜索的item，搜索结果以及搜索历史。在同一个应用中，一个ReviewedStore同样包含了浏览pub的列表以及必要的逻辑比如根据review排序。 但是有一个重要的概念需要记住：Stores并不是仓库。它们的职责不是从一个外部源（API或者数据库）获取数据，而是跟踪actions提供的数据。 那么，Flux application是如何获得数据的呢？ 网络请求与异步调用在第一幅Flux示意图中我有意跳过了一部分：网络调用。接下来的示意图完善第一幅图并添加了更多细节： 异步网络调用是被一个Actions Creator触发的。一个Network 适配器完成相应API的异步调用并且返回结果给Actions Creator。 最终Actions Creator分发带有返回数据的相应类型的Action。 把所有网络工作和异步工作独立于Stores之外有两个主要的优点： 你的Stores是完全同步的：这让Store中的逻辑更容易跟踪。Bug也更容易跟踪。同时，因为所有的状态变化都是同步的，那么Store的测试变会的非常简单：启动actions然后等待期望的结果。 所有的action都是从一个Action Creator触发的：在一处单一的点创建与发起所有用户操作可以大大简化寻找错误的过程。忘掉在多个类中寻找某个操作的源头吧 ，所有的事情都是在这里发生的。同时，因为异步调用发生在这之前，所有来自于ActionCreator的东西都是同步的。这大大提高了代码的可跟踪与可测试性。 演示代码：To－Do应用在这个例子中，你将看到一个使用Flux架构的典型的To-Do应用。 我让项目尽量简单，只演示这个架构如何能够产生组织良好的app。 对于实现的一些评价： Dispatcher的实现是通过Otto Bus。但是几乎任何bus都是可以的。Flux架构本身在事件上有一定限制，我在这里没有采用。原本Flux的定义中，前一个事件没有完成之前就开始分发下一个事件是不允许的，会抛出一个异常。为了让项目简单，我没有采用。有一个ActionsCreator类帮助创建Action，并把它们post给Dispatcher。这在Flux中时相当普遍的模式，可以让事情变的有序。Actions类型只是String常量。也许这不是最好的实现，但是它快速并且有助于事情的简单化。同样的还有Actions数据：它们只是以String类型为key，Object为值的HashMap。这会导致Stores中转换成实际数据的时候发生丑陋的类型转换。而且显然这也不是类型安全的，但这也是为了让我们的例子更好理解。 总结在安卓应用中其实不存在最佳架构的说法。不过存在适合你当前app的最佳架构。这个架构可以让你和团队其他成员协作起来更轻松，按时完成项目，尽可能的保持高质量与较少的bug。 我相信Flux对于以上提到的特点都有很好的支持。 源码https://github.com/lgvalle/android-flux-todo-app 扩展阅读: Facebook Flux Overview Testing Flux Applications Flux architecture Step by Step Async Requests and Flux Flux and Android 英文原文 http://lgvalle.xyz/2015/08/04/flux-architecture/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android软件架构]]></title>
    <url>%2F2015%2F11%2F07%2Fsome-software-architecture%2F</url>
    <content type="text"><![CDATA[写在前面的几句话一个好的软件架构可以降低软件耦合度、提高可复用性、增强软件稳健性、提高代码的阅读美感等等。那么我们接下来就介绍下Android平台下常用的MVC、 MVP和MVVM软件架构。 MVC设计模式即Model View Controller，MVC设计模式将应用程序分为三个主要方面：即Model，View和Controller。 Model模型表示一组描述业务逻辑的类，即业务模型以及数据访问操作，即数据模型。它还定义了数据的业务规则，比如如何更改和操作数据。 View视图表示UI组件。它只负责显示从控制器接收的数据。也就是将模型转换为UI。 Controller控制器负责处理传入的请求。它通过View从用户接收输入，然后在Model的帮助下处理用户的数据，并将结果传递回View。通常，它充当View和模型之间的协调器。 总的来说就是通过controller的控制去操作model层的数据，并且返回给view层展示，当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。 MVP设计模式即Model View Presenter，这种模式类似于MVC模式，其中Controller被Presenter取代。这种设计模式将应用程序分为三层：Model、View、Presenter。 Model模型表示一组描述业务逻辑和数据的类。它还定义了数据的业务规则，比如如何更改和操作数据。 View视图表示UI组件。它只负责显示从Presenter接收的数据。也就是将模型转换为UI。 PresenterPresenter负责代表视图处理所有UI事件。通过View从用户接收输入，然后在Model的帮助下处理用户的数据并将结果传递回View。与MVC不同，View和Presenter彼此完全解耦，并通过接口相互通信。 MVP模式的特点 用户与视图交互。 View和Presenter之间存在一对一的关系。 View具有对Presenter的引用，但是View没有引用Model。 提供View和Presenter之间的双向通信。 MVVM即Model View ViewModel。此模式支持视图和视图模型之间的双向数据绑定。这使得能够在视图模型的状态下将更改自动传递到视图。通常，MVVM使用观察者模式来通知View中的更改。 ModelModel表示一组描述业务逻辑和数据的类。它还定义了数据的业务规则，比如如何更改和操作数据。 ViewView表示UI组件。它只负责显示从控制器接收的数据，将模型转换为UI。 ViewModelViewModel负责公开方法，命令和其他属性，以帮助维护视图的状态，操作模型作为视图上的操作的结果，并触发视图本身中的事件。 MVVM模式的特点 用户与视图交互。 View和ViewModel之间存在多对一的关系意味着许多View可以映射到一个ViewModel。 View具有对ViewModel的引用，但ViewModel没有有关视图的信息。 支持View和ViewModel之间的双向数据绑定。 对比结论与分析通过代码的对比，明显可以发现Mvp模式下的代码量相对来说确实增加了很多，但是逻辑相对的更加清晰，所以我觉得Mvp模式不是很适合小型的项目，小型项目整一堆类出来确实不是很好的事情，但是如果是一个较大型的项目还是可以选用这种架构来做开发，毕竟逻辑清晰，维护起来也比较方便。 而MVVM的架构我觉得是Android往后发展的趋势，毕竟谷歌都推出了Datebinding,而使用Datebinding也就可以不用去使用bufferknife了，而且绑定的这种机制也确实带来了Model,View与ViewModel的分离，从逻辑上看也确实清晰了很多，问题是暂时只支持单向绑定，这个也要等谷歌后面的更新了，而且代码的阅读性会下降很多，所以呢这个比较时候小型的极客项目，暂时不适合大型的项目。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android StaticLayout用法]]></title>
    <url>%2F2015%2F11%2F06%2Fusage-of-android-staticlayout%2F</url>
    <content type="text"><![CDATA[缘由使用Canvas的drawText绘制文本是不会自动换行的，即使一个很长很长的字符串，drawText也只显示一行，超出部分被隐藏在屏幕之外。可以逐个计算每个字符的宽度，通过一定的算法将字符串分割成多个部分，然后分别调用drawText一部分一部分的显示， 但是这种显示效率会很低。 扩展这里介绍下TextView的基本渲染原理，总的来说，TextView中负责渲染文字的主要是这三个类： BoringLayout主要负责显示单行文本，并提供了isBoring方法来判断是否满足单行文本的条件。 DynamicLayout当文本为Spannable的时候，TextView就会使用它来负责文本的显示，在内部设置了SpanWatcher，当检测到span改变的时候，会进行reflow，重新计算布局。 StaticLayout当文本为非单行文本，且非Spannable的时候，就会使用StaticLayout，内部并不会监听span的变化，因此效率上会比DynamicLayout高，只需一次布局的创建即可，但其实内部也能显示SpannableString，只是不能在span变化之后重新进行布局而已。 以上三个类都继承于Layout类，在此类中统一负责文本的具体绘制，在Layout.draw方法中，会对文本一行一行的进行渲染。 StaticLayoutStaticLayout是android中处理文字换行的一个工具类，StaticLayout已经实现了文本绘制换行处理，下面是如何使用StaticLayout的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.amdroidstaticlayoutdemo;import android.support.v4.app.Fragment;import android.text.Layout.Alignment;import android.text.StaticLayout;import android.text.TextPaint;import android.app.Activity;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Paint.Style;import android.os.Bundle;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.os.Build;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new MyView(this)); &#125; public class MyView extends View &#123; Paint mPaint; //画笔,包含了画几何图形、文本等的样式和颜色信息 public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs)&#123; super(context, attrs); &#125; public void onDraw(Canvas canvas)&#123; super.onDraw(canvas); TextPaint tp = new TextPaint(); tp.setColor(Color.BLUE); tp.setStyle(Style.FILL); tp.setTextSize(50); String message = &quot;paint,draw paint指用颜色画,如油画颜料、水彩或者水墨画,而draw 通常指用铅笔、钢笔或者粉笔画,后者一般并不涂上颜料。两动词的相应名词分别为p&quot;; StaticLayout myStaticLayout = new StaticLayout(message, tp, canvas.getWidth(), Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false); myStaticLayout.draw(canvas); canvas.restore(); &#125; &#125; &#125; 这跟TextView的效果是一样的，其实TextView也是调用StaticLayout来实现换行的，StaticLayout的构造函数有三个： 1234567891011121314151617181920212223242526272829public StaticLayout(CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad) public StaticLayout(CharSequence source, int bufstart, int bufend, TextPaint paint, int outerwidth, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad) public StaticLayout(CharSequence source, int bufstart, int bufend, TextPaint paint, int outerwidth, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad, TextUtils.TruncateAt ellipsize, int ellipsizedWidth) 需要分行的字符串 需要分行的字符串从第几的位置开始 需要分行的字符串到哪里结束 画笔对象 layout的宽度，字符串超出宽度时自动换行 layout的对其方式，有ALIGN_CENTER， ALIGN_NORMAL， ALIGN_OPPOSITE 三种 相对行间距，相对字体大小，1.5f表示行间距为1.5倍的字体高度。 在基础行距上添加多少 实际行间距等于这两者的和 参数未知 从什么位置开始省略 超过多少开始省略 需要指出的是这个layout是默认画在Canvas的(0,0)点的，如果需要调整位置只能在draw之前移Canvas的起始坐标canvas.translate(x,y); 参考 TextView预渲染研究 android staticlayout使用讲解 [译]Instagram是如何提升TextView渲染性能的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见直播协议及霹雳云直播介绍]]></title>
    <url>%2F2015%2F11%2F01%2Fintroduce-pili-streaming-cloud%2F</url>
    <content type="text"><![CDATA[常见直播协议的介绍国内常见公开的直播协议有几个：RTMP、HLS、HDL（HTTP-FLV）、RTP，我们来逐一介绍。 RTMP协议：即Real Time Messaging Protocol，是Adobe的专利协议，现在大部分国外的CDN已不支持。在国内流行度很高。原因有几个方面： 1、开源软件和开源库的支持稳定完整。如斗鱼主播常用的OBS软件，开源的librtmp库，服务端有nginx-rtmp插件。 2、播放端安装率高。只要浏览器支持FlashPlayer就能非常简易的播放RTMP的直播，协议详解可以Google了解。相对其他协议而言，RTMP协议初次建立连接的时候握手过程过于复杂（底层基于TCP，这里说的是RTMP协议本身的交互），视不同的网络状况会带来给首开带来100ms以上的延迟。基于RTMP的直播一般内容延迟在2~5秒。 HDL（HTTP-FLV）协议：即使用HTTP协议流式的传输媒体内容。相对于RTMP，HTTP更简单和广为人知，而且不担心被Adobe的专利绑架。内容延迟同样可以做到2~5秒，打开速度更快，因为HTTP本身没有复杂的状态交互。所以从延迟角度来看，HDL（HTTP-FLV）要优于RTMP。 HLS 协议：即Http Live Streaming，是由苹果提出基于HTTP的流媒体传输协议。HLS有一个非常大的优点：HTML5可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享，不需要安装任何独立的APP，有浏览器即可，所以流行度很高。社交直播APP，HLS可以说是刚需，下来我们分析下其原理 。 基于HLS的直播流URL是一个m3u8的文件，里面包含了最近若干个小视频TS（一种视频封装格式，这里就不扩展介绍）文件，如 http://www.ucloud.cn/helloworld.m3u8 是一个直播流留链接，其内容如下： RTP协议：即Real-time Transport Protocol，用于Internet上针对多媒体数据流的一种传输层协议。实际应用场景下经常需要RTCP（RTP Control Protocol）配合来使用，可以简单理解为RTCP传输交互控制的信令，RTP传输实际的媒体数据。 霹雳云直播工作流模型 Client (iOS/Android/PC/Camera) 向 Server (业务逻辑服务器) 请求推流授权 Server 颁发带授权信息的 Stream 给 Client Client 通过 RTMP 推流 给 Pili Streaming Cloud Client 向 Server 请求播放授权 Server 向 Client 颁发播放地址 Client 调用 播放器 SDK 打开播放地址进行播放 三方交互的业务逻辑可以借鉴如下示意图进行理解： Android端SDK播放器 SDK PLDroidPlayer 是一个适用于 Android 的音视频播放器 SDK，可高度定制化和二次开发，特色是支持 RTMP 和 HLS 直播流媒体、以及常见音视频文件（如 MP4、M4A ）播放。 功能特性 基于 ijkplayer ( based on ffplay ) Android Min API 9 支持 RTMP, HLS 协议 支持 ARMv7a 支持 MediaCodec 硬解码 提供 VideoView 控件 可定制化的 MediaController 支持 seekTo() 支持获取当前播放时长 getDuration() 支持获取当前播放的位置 getCurrentPosition() 支持音量控制 setVolume() 提供如下接口： OnPreparedListener OnCompletionListener OnErrorListener OnInfoListener RTMP 直播推流 SDK PLDroidCameraStreaming 是一个适用于 Android 的 RTMP 直播推流 SDK，可高度定制化和二次开发。特色是支持 Android Camera 画面捕获并进行 H.264 硬编码， 以及支持 Android 麦克风音频采样并进行 AAC 硬编码；同时，还实现了一套可供开发者选择的编码参数集合，以便灵活调节相应的分辨率和码率。借助 PLDroidCameraStreaming ，开发者可以快速构建一款类似 Meerkat 或 Periscope 的 Android 直播应用 功能特性 支持 MediaCodec 硬编码 支持 AAC 音频编码 支持 H264 视频编码 内置生成安全的 RTMP 推流地址 支持 RTMP 协议推流 支持 ARMv7a Android Min API 18 支持前后置摄像头，以及动态切换 支持自动对焦 支持闪光灯操作 支持纯音频推流，以及后台运行]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Android上使用Https]]></title>
    <url>%2F2015%2F10%2F31%2Fhow-to-use-https-in-android%2F</url>
    <content type="text"><![CDATA[基础知识HTPPS和HTTP的概念HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTPS和HTTP的区别HTTPS协议需要到ca申请证书，一般免费证书很少，需要交费。 HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的ssl加密传输协议。 HTTP和HTTPS使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 HTTP的连接很简单,是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全 HTTPS解决的问题：信任主机的问题、通讯过程中的数据的泄密和被窜改问题。 HTTPS在Android上的使用HTTPS Get请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.test; import android.os.Handler; import android.os.Message; import android.util.Log; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.HttpVersion; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpGet; import org.apache.http.conn.ClientConnectionManager; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; import java.net.SocketException; import java.net.UnknownHostException; import java.security.KeyStore; /** * Https get请求 */ public class HttpsGetThread extends Thread &#123; private Handler handler; private String httpUrl; private int mWhat; // public static final int ERROR = 404; // public static final int SUCCESS = 200; public HttpsGetThread(Handler handler, String httpUrl) &#123; super(); this.handler = handler; this.httpUrl = httpUrl; mWhat = 200; &#125; public HttpsGetThread(Handler handler, String httpUrl, int what) &#123; super(); this.handler = handler; this.httpUrl = httpUrl; mWhat = what; &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; HttpParams httpParameters = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpParameters, 10000); HttpConnectionParams.setSoTimeout(httpParameters, 10000); HttpClient hc = getHttpClient(httpParameters); HttpGet get = new HttpGet(httpUrl); get.setParams(httpParameters); HttpResponse response = null; try &#123; response = hc.execute(get); &#125; catch (UnknownHostException e) &#123; throw new Exception(&quot;Unable to access &quot; + e.getLocalizedMessage()); &#125; catch (SocketException e) &#123; throw new Exception(e.getLocalizedMessage()); &#125; int sCode = response.getStatusLine().getStatusCode(); if (sCode == HttpStatus.SC_OK) &#123; String result = EntityUtils.toString(response.getEntity(), HTTP.UTF_8); handler.sendMessage(Message.obtain(handler, mWhat, result)); // 请求成功 Log.i(&quot;info&quot;, &quot;result = &quot; + result); &#125; else &#123; String result = EntityUtils.toString(response.getEntity(), HTTP.UTF_8); Log.i(&quot;info&quot;, &quot;result = &quot; + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Log.i(&quot;info&quot;, &quot;=============异常退出==============&quot;); handler.sendMessage(Message.obtain(handler, 404, &quot;异常退出&quot;)); &#125; super.run(); &#125; /** * 获取HttpClient * * @param params * @return */ public static HttpClient getHttpClient(HttpParams params) &#123; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore .getDefaultType()); trustStore.load(null, null); SSLSocketFactory sf = new SSLSocketFactoryImp(trustStore); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); HttpProtocolParams.setUseExpectContinue(params, true); // 设置http https支持 SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme(&quot;http&quot;, PlainSocketFactory .getSocketFactory(), 80)); registry.register(new Scheme(&quot;https&quot;, sf, 443));// SSL/TSL的认证过程，端口为443 ClientConnectionManager ccm = new ThreadSafeClientConnManager( params, registry); return new DefaultHttpClient(ccm, params); &#125; catch (Exception e) &#123; return new DefaultHttpClient(params); &#125; &#125; &#125; HTTPS Post请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.test; import android.os.Handler; import android.os.Message; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.HttpVersion; import org.apache.http.NameValuePair; import org.apache.http.client.HttpClient; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.ClientConnectionManager; import org.apache.http.conn.params.ConnManagerParams; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; import java.net.SocketException; import java.net.UnknownHostException; import java.security.KeyStore; import java.util.List; /** * Https Post请求 */ public class HttpsPostThread extends Thread &#123; private Handler handler; private String httpUrl; private List&lt;NameValuePair&gt; valueList; private int mWhat; public static final int ERROR = 404; public static final int SUCCESS = 200; public HttpsPostThread(Handler handler, String httpUrl, List&lt;NameValuePair&gt; list, int what) &#123; super(); this.handler = handler; this.httpUrl = httpUrl; this.valueList = list; this.mWhat = what; &#125; public HttpsPostThread(Handler handler, String httpUrl, List&lt;NameValuePair&gt; list) &#123; super(); this.handler = handler; this.httpUrl = httpUrl; this.valueList = list; this.mWhat = SUCCESS; &#125; @Override public void run() &#123; // TODO Auto-generated method stub String result = null; try &#123; HttpParams httpParameters = new BasicHttpParams(); // 设置连接管理器的超时 ConnManagerParams.setTimeout(httpParameters, 10000); // 设置连接超时 HttpConnectionParams.setConnectionTimeout(httpParameters, 10000); // 设置socket超时 HttpConnectionParams.setSoTimeout(httpParameters, 10000); HttpClient hc = getHttpClient(httpParameters); HttpPost post = new HttpPost(httpUrl); post.setEntity(new UrlEncodedFormEntity(valueList, HTTP.UTF_8)); post.setParams(httpParameters); HttpResponse response = null; try &#123; response = hc.execute(post); &#125; catch (UnknownHostException e) &#123; throw new Exception(&quot;Unable to access &quot; + e.getLocalizedMessage()); &#125; catch (SocketException e) &#123; throw new Exception(e.getLocalizedMessage()); &#125; int sCode = response.getStatusLine().getStatusCode(); if (sCode == HttpStatus.SC_OK) &#123; result = EntityUtils.toString(response.getEntity(), HTTP.UTF_8); if (handler != null) &#123; handler.sendMessage(Message.obtain(handler, mWhat, result)); // 请求成功 &#125; &#125; else &#123; result = &quot;请求失败&quot; + sCode; // 请求失败 // 404 - 未找到 if (handler != null) &#123; handler.sendMessage(Message.obtain(handler, ERROR, result)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (handler != null) &#123; result = &quot;请求失败,异常退出&quot;; handler.sendMessage(Message.obtain(handler, ERROR, result)); &#125; &#125; super.run(); &#125; /** * 获取HttpClient * * @param params * @return */ public static HttpClient getHttpClient(HttpParams params) &#123; try &#123; KeyStore trustStore = KeyStore.getInstance(KeyStore .getDefaultType()); trustStore.load(null, null); SSLSocketFactory sf = new SSLSocketFactoryImp(trustStore); sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1); HttpProtocolParams.setContentCharset(params, HTTP.UTF_8); HttpProtocolParams.setUseExpectContinue(params, true); // 设置http https支持 SchemeRegistry registry = new SchemeRegistry(); registry.register(new Scheme(&quot;http&quot;, PlainSocketFactory .getSocketFactory(), 80)); registry.register(new Scheme(&quot;https&quot;, sf, 443));// SSL/TSL的认证过程，端口为443 ClientConnectionManager ccm = new ThreadSafeClientConnManager( params, registry); return new DefaultHttpClient(ccm, params); &#125; catch (Exception e) &#123; return new DefaultHttpClient(params); &#125; &#125; &#125; SSLSocketFactoryImp类:如果要进行证书认证,可以在该方法中实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.test; import java.io.IOException; import java.net.Socket; import java.net.UnknownHostException; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.UnrecoverableKeyException; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import org.apache.http.conn.ssl.SSLSocketFactory; public class SSLSocketFactoryImp extends SSLSocketFactory &#123; final SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); public SSLSocketFactoryImp(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException &#123; super(truststore); TrustManager tm = new X509TrustManager() &#123; public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; @Override public void checkClientTrusted( java.security.cert.X509Certificate[] chain, String authType) throws java.security.cert.CertificateException &#123; &#125; @Override public void checkServerTrusted( java.security.cert.X509Certificate[] chain, String authType) throws java.security.cert.CertificateException &#123; &#125; &#125;; sslContext.init(null, new TrustManager[] &#123; tm &#125;, null); &#125; @Override public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException &#123; return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose); &#125; @Override public Socket createSocket() throws IOException &#123; return sslContext.getSocketFactory().createSocket(); &#125; &#125; 测试类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.test; import android.app.Activity; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.util.Log; import android.view.View; import android.widget.Button; import org.apache.http.NameValuePair; import org.apache.http.message.BasicNameValuePair; import java.util.ArrayList; import java.util.List; public class MainActivity extends Activity &#123; private Button btn, btn1; private Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); initData(); &#125; private void initView() &#123; btn = (Button) findViewById(R.id.btn); btn1 = (Button) findViewById(R.id.btn1); &#125; private void initListener() &#123; btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;(); HttpsPostThread thread = new HttpsPostThread(mHandler, &quot;https://certs.cac.washington.edu/CAtest/&quot;, list, 200); thread.start(); &#125; &#125;); btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; HttpsGetThread thread = new HttpsGetThread(mHandler, &quot;https://certs.cac.washington.edu/CAtest/&quot;, 200); thread.start(); &#125; &#125;); &#125; private void initData() &#123; mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); String result = (String) msg.obj; switch (msg.what) &#123; case 200: // 请求成功 Log.e(&quot;TAG&quot;, &quot;返回参数===&quot; + result); break; case 404: // 请求失败 Log.e(&quot;TAG&quot;, &quot;请求失败!&quot;); break; &#125; &#125; &#125;; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SDK Mirror搭建和使用]]></title>
    <url>%2F2015%2F10%2F20%2Fbuild-private-android-sdk-mirror%2F</url>
    <content type="text"><![CDATA[缘由前段时间XcodeGhost闹的沸沸扬扬，意外发现迅雷下载真的是可以被污染的，这个很有意思，详情见对迅雷下载进行投毒的简单尝试，也提醒了开发者不要随意从非官方渠道下载开发工具。 我们都知道Android SDK由于国内网络环境的原因，下载速度很慢，有很多国内搭建的镜像，但镜像服务器下载带宽肯定有一定限制，并且内网一般也会限制下载速度。所以在内网搭建一个Android SDK镜像服务器很有必要，一方面可以保证速度，几兆每秒肯定不成问题，另一方面大家从内网下载，也可以保证安全性。貌似有的团队用FTP存储SDK，还是太Low了，用起来肯定不如镜像方便。 搭建Android SDK镜像服务器，有两个现成的开源解决方案，苏州GDG和中科院开源镜像小组，苏州GDG牛皮吹的很响，貌似还在某个会议上发表过演讲，但估计是个人作品，东西不够完善，更新缓慢。中科院开源镜像小组开源的方案非常不错，并且也对外开放了镜像服务，一直运行良好，Github上还有定时同步和Nginx的配置信息。 花了一个下午的时间，搞定了内网Android SDK镜像服务器，下载速度平均5M/s，效果杠杠的。 下载SDK直接运行android.py脚本，由于SDK下载需要翻墙，所以你可能需要代理。命令行程序默认不走你的全局代理，我在家用sock5代理，在mac下用的是proxychains4，公司内网有Http代理服务器，想在命令行中使用，需要设置http_proxy和https_proxy环境变量，临时使用直接在终端中输入： 12export http_proxy=http://yourproxyaddress:proxyportexport https_proxy=http://yourproxyaddress:proxyport 细看脚本，你会发现脚本会先去下载repository-.xml和addons_list-.xml，xml里面是一些文件的具体下载地址，包含sdk、build_tools、support包等等，然后去下载具体的文件。 服务器配置因为最终搭建的镜像要作为代理服务器，在SDK Manager中配置，所以需要你配置ngnix的虚拟主机。在/etc/nginx/conf.d/default.conf文件中，修改server_name字段： 12server_name dl.google.com dl-ssl.google.com; 因为当SDK Manger配置你的镜像作为代理后，首先会拉取xml配置文件，比如https://dl.google.com/android/repository/repository-11.xml，最终会找到镜像服务器的android/repository/repository-11.xml文件，下载其他SDK文件也是同样，所以需要你把之前运行脚本下载的文件放到正确的目录中。 使用 动 Android SDK Manager ，打开主界面，依次选择『Tools』、『Options…』，弹出『Android SDK Manager - Settings』窗口； 在『Android SDK Manager - Settings』窗口中，在『HTTP Proxy Server』和『HTTP Proxy Port』输入框内填入上面镜像服务器地址(不包含http://，如图)和端口并且选中『Force https://… sources to be fetched using http://…』复选框。 设置完成后单击『Close』按钮关闭『Android SDK Manager - Settings』窗口返回到主界面，依次选择『Packages』、『Reload』。 参考 http://jiajixin.cn/2015/10/11/android-sdk-mirror/ http://www.androiddevtools.cn/]]></content>
      <tags>
        <tag>基础服务搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图极速入门]]></title>
    <url>%2F2015%2F10%2F16%2Flean-uml-fast%2F</url>
    <content type="text"><![CDATA[UML类图有以下几种常见的关系: 泛化（Generalization） 123【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。【箭头指向】：带三角箭头的实线，箭头指向父类 实现（Realization） 123【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.【箭头指向】：带三角箭头的虚线，箭头指向接口 关联（Association) 12345【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者 聚合（Aggregation） 123456【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体 组合(Composition) 123456【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体 依赖(Dependency) 12345【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者]]></content>
      <tags>
        <tag>UML与设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命万岁]]></title>
    <url>%2F2015%2F10%2F10%2Fviva-la-vida%2F</url>
    <content type="text"><![CDATA[I used to rule the world大千世界曾由我主宰Seas would rise when I gave the word巨浪也曾因我之命澎湃Now in the morning I sleep alone而今我却在黎明独自入眠Sweep the streets I used to own在曾属于我的大道落寞徘徊 I used to roll the dice大千世界曾由我主宰Feel the fear in my enemy’s eyes尽情品味惊恐在死敌瞳孔绽开Listen as the crowd would sing:欣然倾听百姓高歌喝彩“Now the old king is dead! Long live the king!”“先王亡矣！”“新王万代！”One minute I held the key此刻我手握权位经脉Next the walls were closed on me转瞬才知宫墙深似海And I discovered that my castles stand恍然发现我的城池Upon pillars of salt, pillars of sand基底散如盐沙乱似尘埃 I hear Jerusalem bells a-ringing听那耶路撒冷钟声传来Roman Cavalry choirs are singing罗马骑兵歌声震彻山海Be my mirror my sword and shield担当我的明镜，利剑和盾牌My missionaries in a foreign field我的传教士屹立边疆之外For some reason I can not explain只因一些缘由我无法释怀Once you go there was never, never an honest word一旦你离开这里便不再,不再有逆耳忠言存在That was when I ruled the world而这便是我统治的时代 It was the wicked and wild wind凛冽邪风呼啸袭来Blew down the doors to let me in.吹散重门使我深陷阴霾Shattered windows and the sound of drums断壁残垣礼崩乐坏People could not believe what I’d become世人不敢相信我已当年不再Revolutionaries Wait起义大军翘首期待For my head on a silver plate有朝一日我站上断头台Just a puppet on a lonely string恰如傀儡随吊线寂寞摇摆Oh who would ever want to be king?悲哉，谁又曾渴望万人膜拜？ I hear Jerusalem bells a-ringing听那耶路撒冷钟声传来Roman Cavalry choirs are singing罗马骑兵歌声震彻山海Be my mirror my sword and shield担当我的明镜，利剑和盾牌My missionaries in a foreign field我的传教士屹立边疆之外For some reason I can not explain只因一些缘由我无法释怀I know Saint Peter won’t call my name我亦知天堂之门不会为我敞开Never an honest word不再有逆耳忠言存在But that was when I ruled the world而这便是我统治的时代 (Ohhhhh Ohhh Ohhh)(哦哦哦)Hear Jerusalem bells a-ringing听那耶路撒冷钟声传来Roman Cavalry choirs are singing罗马骑兵歌声震彻山海Be my mirror my sword and shield担当我的明镜，利剑和盾牌My missionaries in a foreign field我的传教士屹立边疆之外For some reason I can not explain只因一些缘由我无法释怀I know Saint Peter won’t call my name我亦知天堂之门不会为我敞开Never an honest word不再有逆耳忠言存在But that was when I ruled the world而这便是我统治的时代]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NDK进行OpenGL开发]]></title>
    <url>%2F2015%2F10%2F09%2Fdevelopment-opengles-with-ndk-on-android%2F</url>
    <content type="text"><![CDATA[缘由Android SDK 提供了一套 OpenGL ES 接口，但该接口是基于 Java 的，速度非常慢，往往很难满足需要。NDK 提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动 将 so和 java 应用一起打包成 apk。使用 NDK，我们可以将要求高性能的应用 逻辑使用C开发，从而提高应用程序的执行效率。如 OpenGL ES 的程序。 对于 NDK，在 Java 代码中调用 C/C++ 代码是通过 JNI 实现的。 Java Native Interface（JNI）是 Java 语言的本地编程接口，在java程序中， 我们可以通过 JNI 实现一些用 java 语言不便实现的功能。通常有以下几种情 况我们需要使用 JNI 来实现： java 类库没有提供你的应用程序所需要的功能，通常这些功能是平台相关的; 你希望使用一些已经有的类库或者应用程序，而他们并非用java语言编写的； 程序的某些部分对速度要求比较苛刻，你选择用汇编或者 c 语言来实现并在 java 语言中调用他们。 注意，不到万不得已不要使用 JNI 技术，一方面它需要你把握更多的知识才可 以驾驭，一方面使用了 JNI 你的程序就会丧失可移植性。 OpenGL ESJava 端核心代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class DemoAct extends Activity &#123; private GLSurfaceView mGLView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mGLView = new DemoGLSurfaceView(this); setContentView(mGLView); &#125; ... ... static &#123; System.loadLibrary(&quot;sanangeles&quot;); &#125;&#125;class DemoGLSurfaceView extends GLSurfaceView &#123; DemoRenderer mRenderer; public DemoGLSurfaceView(Context context) &#123; super(context); mRenderer = new DemoRenderer(); setRenderer(mRenderer); &#125;class DemoRenderer implements GLSurfaceView.Renderer &#123; private static native void nativeInit(); private static native void nativeResize(int w, int h); private static native void nativeRender(); private static native void nativeDone(); public void onSurfaceCreated(GL10 gl, EGLConfig config) &#123; nativeInit(); &#125; public void onSurfaceChanged(GL10 gl, int w, int h) &#123; nativeResize(w, h); &#125; public void onDrawFrame(GL10 gl) &#123; nativeRender(); &#125;｝ JNI 代码如下所示：1234567891011121314151617181920212223242526#include &lt;jni.h&gt;.../* Call to initialize the graphics state */voidJava_com_example_AndMii_DemoRenderer_nativeInit( JNIEnv* env )&#123; appInit();&#125;/* Call to finalize the graphics state */voidJava_com_example_AndMii_DemoRenderer_nativeDone( JNIEnv* env )&#123; free objects.&#125;/* Call to render the next GL frame */voidJava_com_example_AndMii_DemoRenderer_nativeRender( JNIEnv* env )&#123; curTime = ... appRender(curTime, sWindowWidth, sWindowHeight);&#125; C 语言端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void appInit()&#123; glEnable(GL_NORMALIZE); glEnable(GL_DEPTH_TEST); glDisable(GL_CULL_FACE); glShadeModel(GL_FLAT); glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glEnable(GL_LIGHT1); glEnable(GL_LIGHT2); glEnableClientState(GL_VERTEX_ARRAY); glEnableClientState(GL_COLOR_ARRAY);&#125;// Called from the app framework./* The tick is current time in milliseconds, width and height* are the image dimensions to be rendered.*/void appRender(long tick, int width, int height)&#123; // Prepare OpenGL ES for rendering of the frame. prepareFrame(width, height); // Configure environment. configureLightAndMaterial(); // Draw all the models normally. drawModels(1);&#125;static void prepareFrame(int width, int height)&#123; glViewport(0, 0, width, height); glClearColorx((GLfixed)(0.1f * 65536), (GLfixed)(0.2f * 65536), (GLfixed)(0.3f * 65536), 0x10000); glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(45, (float)width / height, 0.5f, 150); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;static void configureLightAndMaterial()&#123; static GLfixed light0Position[] = &#123; -0x40000, 0x10000, 0x10000, 0 &#125;; static GLfixed light0Diffuse[] = &#123; 0x10000, 0x6666, 0, 0x10000 &#125;; static GLfixed light1Position[] = &#123; 0x10000, -0x20000, -0x10000, 0 &#125;; static GLfixed light1Diffuse[] = &#123; 0x11eb, 0x23d7, 0x5999, 0x10000 &#125;; static GLfixed light2Position[] = &#123; -0x10000, 0, -0x40000, 0 &#125;; static GLfixed light2Diffuse[] = &#123; 0x11eb, 0x2b85, 0x23d7, 0x10000 &#125;; static GLfixed materialSpecular[] = &#123; 0x10000, 0x10000, 0x10000, 0x10000 &#125;; glLightxv(GL_LIGHT0, GL_POSITION, light0Position); glLightxv(GL_LIGHT0, GL_DIFFUSE, light0Diffuse); glLightxv(GL_LIGHT1, GL_POSITION, light1Position); glLightxv(GL_LIGHT1, GL_DIFFUSE, light1Diffuse); glLightxv(GL_LIGHT2, GL_POSITION, light2Position); glLightxv(GL_LIGHT2, GL_DIFFUSE, light2Diffuse); glMaterialxv(GL_FRONT_AND_BACK, GL_SPECULAR, materialSpecular); glMaterialx(GL_FRONT_AND_BACK, GL_SHININESS, 60 &lt;&lt; 16); glEnable(GL_COLOR_MATERIAL);&#125;static void drawModels(float zScale)&#123; glVertexPointer(......); glColorPointer(......); if (normalArray != NULL) &#123; glNormalPointer(GL_FIXED, 0, normalArray); glEnableClientState(GL_NORMAL_ARRAY); &#125; else glDisableClientState(GL_NORMAL_ARRAY); glDrawArrays(GL_TRIANGLES, 0, object-&gt;count);&#125; 调试要想在 jni native 代码中看打印信息，printf 是不行的，需使用 __android_log_print，如下所示。 1__android_log_print(ANDROID_LOG_INFO, &quot;ProjectName&quot;, &quot;I am : %d\n&quot;, n); 该函数与 printf 用法相似，使用格式字符。打印的结果通过 logcat 查看。注意，使用时需要将头文件 android/log.h 包含进来。为方便使用，往往定义一些宏 123456#include &lt;android/log.h&gt;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, &quot;ProjectName&quot;, __VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , &quot;ProjectName&quot;, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , &quot;ProjectName&quot;, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN , &quot;ProjectName&quot;, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , &quot;ProjectName&quot;, __VA_ARGS__)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
</search>
